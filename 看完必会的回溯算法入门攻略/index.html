<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="小猫咪吃python" href="http://yoursite.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="小猫咪吃python" href="http://yoursite.com/atom.xml"><link rel="alternate" type="application/json" title="小猫咪吃python" href="http://yoursite.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/css/app.css?v=0.2.5"><meta name="keywords" content="LeetCode,AcWing,经典必会,深度优先搜索(DFS),回溯"><link rel="canonical" href="http://yoursite.com/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%94%BB%E7%95%A5/"><title>看完必会的回溯算法入门攻略 - 搜索与图论 - 算法 | The Cat to eat Python = 小猫咪吃python = 唤起一天明月 照我满怀冰雪 浩荡百川流 鲸饮未吞海 剑气已横秋</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">看完必会的回溯算法入门攻略</h1><div class="meta"><span class="item" title="创建时间：2022-04-23 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-04-23T00:00:00+08:00">2022-04-23</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">The Cat to eat Python</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclimtf7dj20zk0m8qav.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipesrnqv3j20zk0m8ava.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclh5u05ej20zk0m87df.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipevarprfj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="item" rel="index" title="分类于 算法"><span itemprop="name">算法</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" itemprop="item" rel="index" title="分类于 搜索与图论"><span itemprop="name">搜索与图论</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://yoursite.com/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%94%BB%E7%95%A5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/avatar.jpg"><meta itemprop="name" content="A Cat Without Sugar"><meta itemprop="description" content="唤起一天明月 照我满怀冰雪 浩荡百川流 鲸饮未吞海 剑气已横秋, 孤独与剑，自由与酒"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小猫咪吃python"></span><div class="body md" itemprop="articleBody"><blockquote><p>这是一篇关于回溯算法的<strong>详细的入门级攻略</strong>（真的就只是<strong>入门级</strong>）。</p></blockquote><blockquote><p><strong>一定要看最后的总结呀～</strong></p></blockquote><h1 id="回溯的含义"><a class="anchor" href="#回溯的含义">#</a> 回溯的含义</h1><p><strong>回溯</strong>本质上是<strong>搜索的一种方式</strong>，一般情况下，该搜索指<strong>深度优先搜索（dfs）</strong>。且实现上使用<strong>递归</strong>的方式。</p><h1 id="从全排列开始"><a class="anchor" href="#从全排列开始">#</a> 从 “全排列” 开始</h1><p>全排列是回溯最经典的应用之一，我们以全排列做基本示例，先来理解最简单的回溯是如何执行的。</p><h2 id="leetcode-46-全排列"><a class="anchor" href="#leetcode-46-全排列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLw==">LeetCode 46. 全排列</span></h2><blockquote><p>给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><p>输入样例</p><p>3</p><p>输出样例</p><p>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1</p><p>解释：输入样例为输入的整数 n。输出样例为 1~n 的三个数字 (1,2,3) 的所有排列方式。</p></blockquote><h3 id="简单的思路"><a class="anchor" href="#简单的思路">#</a> 简单的思路</h3><p>先把这道题当做脑筋急转弯，我们很容易就可以想到简单的思路：<strong>分别把不同的数字放到每个位置上</strong>。</p><p>例如：</p><ol><li><code>1 2 3</code> ，总共三个数，所以有三个位置，我们把 <code>1</code> 放在第一个位置，那么第二个位置可以放 <code>2</code> 或 <code>3</code> ，无论第二个位置放哪一个，第三个位置都只能放另外一个，而当三个位置都放完就找到了一个完整的排列方法；</li><li>以此类推的，如果第一个位置放 2，那么第二个位置有两种放置方式；</li><li>如果第一个位置放 3，那么第二个位置同样有两种放置方式；</li><li>我们把这一放置的过程用可视化图形表达出来，会形成一种树的形式：<br><img data-src="/assets/bda9f30f-b019-463d-87cb-3c7c741fd823.png" alt=""></li></ol><h3 id="回溯是在做什么"><a class="anchor" href="#回溯是在做什么">#</a> 回溯是在做什么？</h3><p>请仔细研究一下上面的放置思路，其中有一个隐藏的关键点：<strong>从第一层向下搜索到第三层，找到一个结果之后，需要重新回到第一层；再从第一层延伸到第二层的其他分支。</strong> 也就是说，需要<strong>沿着如下图的红色箭头指向顺序搜索</strong>。<br><img data-src="/assets/e4bb4efb-5bee-4b69-89ed-dd97c7a57c70.png" alt=""></p><p>想要用代码实现这一搜索过程，这一关键点是需要想清楚的：<strong>如何在搜索出一个结果之后，让代码可以往回搜索呢？</strong></p><h3 id="code"><a class="anchor" href="#code">#</a> Code</h3><p><strong>往回搜索</strong>其实就是回溯的过程，先来看下全排列中的代码实现：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span> <span class="token comment">// 存储所有排列方法</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> st<span class="token punctuation">;</span> <span class="token comment">// 存储数字是否被用过</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span> <span class="token comment">// 存储当前排列方法</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 使用递归的实现搜索，其中 u 表示当前已经排列的个数</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 如果已经排列的数字个数和总数字个数相等，说明已经完成一次排列</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 把当前的排列方法放入最终结果，并 return。</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//  ①</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//  ②</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span>                    <span class="token comment">//  ③</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 枚举数字</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ④</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 没有使用过的数字参与排列</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">//  ⑤</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//  ⑥</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>              <span class="token comment">//  ⑦</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//  ⑧</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>             <span class="token comment">//  ⑨</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//  ⑩</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">permute</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><hr><p><strong>接下来是本文重中之重，我们来看一下上面的代码的完整的执行流程，以此来了解为何这样写就能完成回溯。</strong></p><ol><li>首先，要明确的几个关键角色：<ol><li><code>u</code> : 可以理解为 “目前使用了几个数字”、“目前处于树的第几层” 等等；</li><li><code>res</code> : 保存最终结果（所有路径）；</li><li><code>path</code> : 保存当前的路径，保存的是值，比如 nums [0],nums [1] 等；</li><li><code>st（state）</code> : 存储数字是否被使用过，上面代码直接存储的下标（也可以存储值），因此下面分析中 st 也是以下标为准；</li><li><code>nums</code> : 数组，既保存需要排列的数字，如 <code>n=3,nums=[1,2,3]</code> 。</li></ol></li><li>明确递归函数的含义，递归函数最重要的就是其表达的含义，而在上面代码中，递归函数 dfs 的含义是<strong>深度优先搜索，当搜索到一个结果之后，就把结果加入到结果 res</strong>。</li><li><strong>最最最最重要的</strong>，我们来看一下回溯的执行过程：</li></ol><p><img data-src="/assets/34af8b93-4b5a-4d63-83eb-33ce01e667bf.png" alt=""><br><img data-src="/assets/28af88e8-f749-44f1-a8d4-0fb3879f23c8.png" alt=""><br><img data-src="/assets/cd286fdc-8e5f-4840-8de0-ec91340186aa.png" alt=""><br><img data-src="/assets/d8283eb6-1bd9-47ff-852a-1c289cfac7a0.png" alt=""><br><img data-src="/assets/cf335dad-ad38-40cb-8fd2-ead087d49c41.png" alt=""><br><img data-src="/assets/b4e91b61-917b-4d36-b9a4-aedd7c19e8a6.png" alt=""><br><img data-src="/assets/37f6e4e4-5473-469e-a75c-7128a89a7eee.png" alt=""><br><img data-src="/assets/85f51504-dce9-4141-a575-5508cfe678c2.png" alt=""><br><img data-src="/assets/a52eeb88-4b87-4d7b-8ecc-69b476337cd2.png" alt=""><br><img data-src="/assets/3295e083-0ded-4929-b5c7-ebb09b6b72ff.png" alt=""><br><img data-src="/assets/71e39b97-15af-47b0-8494-a706c0af16d3.png" alt=""></p><ol start="4"><li><p><strong>最最最最重要的</strong>，执行过程中的全部变化如下：<br><img data-src="/assets/3a8c0c31-3cb0-419a-9c91-31eef5f800d9.png" alt=""></p></li><li><p>从图中 path 的变化，可以明显的看出，其实代码的执行顺序正好对应了上面图中的搜索顺序。</p></li><li><p>理解回溯（或者说递归），至关重要的一点：<strong>当一个函数让出执行权后，执行权又重新回来，函数当前的变量状态应该和让出前一致。</strong></p><p>以上面的 dfs (1) 为例，在第 ② 步 (不是代码 ②)，递归到 dfs (2) 时候 <strong>dfs (1) 的变量 <code>i</code> 的值是 1</strong>，那么在第 ⑤ 步回到 dfs (1) 的时候，<strong>dfs (1) 的变量 <code>i</code> 的值仍然是 1</strong>，并且从 ** 递归处（代码 ⑧）** 继续向下执行。</p></li></ol><h1 id="总结个板子"><a class="anchor" href="#总结个板子">#</a> 总结个 “板子”</h1><p>根据上面 “全排列” 的解法，我们可以总结出一个<strong>回溯问题的通用思路</strong>，下面用伪代码来描述：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>res<span class="token punctuation">;</span>  <span class="token comment">// 存放结果</span></pre></td></tr><tr><td data-num="2"></td><td><pre>path<span class="token punctuation">;</span> <span class="token comment">// 存放当前的搜索路径</span></pre></td></tr><tr><td data-num="3"></td><td><pre>st<span class="token punctuation">;</span> <span class="token comment">// 判断元素是否已经被使用</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">//u 表示递归处于哪一层</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span> 结束条件 <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">for</span> 循环 <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 剪枝</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// do something~~</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归，进入下一层</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 回溯，撤销 do something~~</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>下面我们就用这种方法，来批量的解决一堆回溯相关问题。</p><h1 id="使用板子解决同类型题目"><a class="anchor" href="#使用板子解决同类型题目">#</a> 使用 “板子” 解决同类型题目</h1><p>充分理解回溯的思路，那么就可以扩展到相同类型的题目上。</p><h2 id="leetcode-47-全排列-ii"><a class="anchor" href="#leetcode-47-全排列-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLWlpLw==">LeetCode 47. 全排列 II</span></h2><blockquote><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p></blockquote><h3 id="思路及实现"><a class="anchor" href="#思路及实现">#</a> 思路及实现</h3><p>全排列的经典扩展，给出的序列 nums 可能包含重复的，那么就需要考虑一个问题：<strong>如何避免重复数字换序后，计算为新的排列方式。</strong></p><p>其实解决的办法很简单：<strong>跳过重复的数字。</strong></p><p>举个例子：当前 nums 为 [1,1,2]，为了便于观察我们给重复的 <code>1</code> 做上标记来进行区分，得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>1</mn><mn>1</mn></msub><mo separator="true">,</mo><msub><mn>1</mn><mn>2</mn></msub><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1_1,1_2,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span></span></span></span> ，那么就会出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>1</mn><mn>1</mn></msub><mo separator="true">,</mo><msub><mn>1</mn><mn>2</mn></msub><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1_1,1_2,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>1</mn><mn>2</mn></msub><mo separator="true">,</mo><msub><mn>1</mn><mn>1</mn></msub><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1_2,1_1,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span></span></span></span> 是同一种排列。</p><p>为了避免这种情况，以最左边的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>1</mn><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">1_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.79444em;vertical-align:-.15em"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 为准，如果出现重复的就跳过去，那么当排列出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>1</mn><mn>1</mn></msub><mo separator="true">,</mo><msub><mn>1</mn><mn>2</mn></msub><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1_1,1_2,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span></span></span></span>，就不会再排列出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>1</mn><mn>2</mn></msub><mo separator="true">,</mo><msub><mn>1</mn><mn>1</mn></msub><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1_2,1_1,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span></span></span></span>。</p><h3 id="code-2"><a class="anchor" href="#code-2">#</a> Code</h3><p>实现上还有一个小细节需要注意下，给出的 nums 可能是乱序的，所以要先排序一下，以方便跳过相同的数字。</p><p>因为是搜索的全排列，所以排序不会对结果产生影响。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> st<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">permuteUnique</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        st <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// path = vector&lt;int>(nums.size());</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token comment">// 剪枝。如果出现重复数字，并且重复数字已经被用了，就跳过。</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>st<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="leetcode-39-组合总和"><a class="anchor" href="#leetcode-39-组合总和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb24tc3Vt">LeetCode 39. 组合总和</span></h2><blockquote><p>给你一个 无重复元素 的整数数组  nums 和一个目标整数  target ，找出  nums  中可以使数字和为目标数  target 的 所有   不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>nums 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为  target 的不同组合数少于 150 个。</p></blockquote><h3 id="思路及实现-2"><a class="anchor" href="#思路及实现-2">#</a> 思路及实现</h3><p>初步看题目，发现与全排列高度相似，但又有些许不同：</p><ol><li>元素可以重复使用；</li><li>结束条件不在是所有数字全部使用，而是当前路径之和为 target；</li></ol><p>那么，实现上我们要解决的一个重要难点就是：<strong>如何让元素可以重复使用呢？</strong></p><ol><li><p>首先，为了逐步增大路径，先给 nums 排个序。</p></li><li><p>因为数字可以重复使用，所以用来判重的 st 也就没必要使用了。</p></li><li><p>最重要的是<strong>使元素重复使用</strong>，我们引入一个新的参数 <code>start</code> ，它表达的含义是<strong>每次递归从 start 开始搜索。</strong></p><p>这样有什么效果？举个例子就清晰了，<strong>我们当前枚举到了 i=2，那么我们把 <code>i</code> 当作参数 <code>start</code> 传到下一层，下一层又会从 <code>start</code> 开始枚举，不就重复使用 i=2 了嘛？</strong></p><p>请读者将上面，加粗的描述多读几遍，细细体会一下 <code>start</code> 是如何解决本题最大难点的。</p></li><li><p><strong>st 与 start 的区别是什么？或者说分别在什么时候使用？</strong></p><ol><li><p>在<strong>全排列</strong>中，因为每个数字只能使用一次，所以我们用了 st 数组，把使用过的数字标记一下，这样在下一层遇到的时候，就可以跳过使用过的。</p><p>例如：当前 <code>i=0，st=[1,0,0]</code> ，下一层重新从 <code>0枚举到3</code> ，当枚举到 <code>0</code> 的时候，发现 <code>st</code> 中 <code>0</code> 已经被使用过了，因此跳过了 <code>0</code> ，继续循环，得到 <code>i=1</code> 。</p><p>所以<strong> st 可以用来判重</strong>。</p></li><li><p>在该问题中，因为数字可以重复使用，所以用来判重的 <code>st</code> 显然就没有存在的必要了。而为了计算重复元素，我们引入 dfs () 的新参数 start，<strong>每次从 start 开始枚举，这样每次把当前 i 的值传给 start，那么下一层还是从当前 i 枚举的</strong>。但是这里引申出一个重要的问题：<strong>下一层递归不从 0 开始重新枚举，不会枚举不全吗？</strong></p><p>答案是：不会的，一个重要原因是<strong>提前将 nums 从小到大，排好了序</strong>，所以从较小的数开始枚举，一定是<strong>一直枚举较小的数，直到较小的数也会超过 target 或者 较小的数加起来等于 target。</strong></p><p>这样，对于<strong>较小的数来说，我们已经全部放入了 path，较小的数的使用个数不能再增多了（只能减少），所以也就没有枚举较小的数的必要了。</strong></p><p>举个例子： <code>nums = [2,3,6,7], target = 7</code> ，假设 nums 已经排序好，那么我们一定是一直枚举最小的数 <code>2</code> ，直到再枚举最小的数 <code>2</code> 也会超过 target。</p><p>那就是 <code>[2,2,2]</code> ，此时下一个 <code>2</code> 会使总和超过 target，所以直接回溯，再枚举 <code>3</code> ，得到结果之一 <code>[2,2,3]</code> 。</p><p>我们发现当前路径 <code>path</code> 达到 <code>[2,2,2]</code> 时，<strong>合法路径中，能容纳的最小数 2 已经到上限了</strong>，无法再增多了，而为了配合后面比他大的数，它只能慢慢减少，直到算法结束～～</p><p>总结一下，<strong>start 可以控制下一次枚举的开始位置</strong>。</p></li></ol></li><li><p>把当前的思路带入到 “板子” 中，会发现实现很简单。</p></li></ol><h3 id="code-3"><a class="anchor" href="#code-3">#</a> Code</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 至关重要的排序</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">//dfs 的参数多加一个 start</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 当前路径和正好等于 target 时，说明找到了一个合法路径。</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// 剪枝。如果超过 target，直接开始回溯。</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token comment">// do something~~</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            target <span class="token operator">-=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//target 减少</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token comment">// 递归。注意 start 处传的参数，是当前的 i，所以下一层递归也会从这个 i 开始，</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// 这样就达到了重复使用数字的目的。</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token comment">// 撤销 do something</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            target <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="leetcode-40-组合总和-ii"><a class="anchor" href="#leetcode-40-组合总和-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb24tc3VtLWlpLw==">LeetCode 40. 组合总和 II</span></h2><blockquote><p>给定一个候选人编号的集合  nums  和一个目标数  target ，找出  nums  中所有可以使数字和为  target  的组合。</p><p>nums  中的每个数字在每个组合中只能使用   一次  。</p><p>注意：解集不能包含重复的组合。</p></blockquote><h3 id="思路及实现-3"><a class="anchor" href="#思路及实现-3">#</a> 思路及实现</h3><p>对比上一道题（组合总和），本题有两个关键点：</p><ol><li><p><strong>数字不可以重复使用</strong></p><p>只要读者认真理解了上面一题 <code>start</code> 的含义，想必很快就能解决这个问题 (就很快啊～)。还记得在上一道题我们讲了 <code>start</code> 的作用吗？我们为了让数字可以重复被使用，所以在 <code>start</code> 位置传了当前枚举的数字 <code>i</code> ，这样下一层枚举也会从 <code>i</code> 开始。那么显然，对于这个问题的该关键点，只要把 start 位置的传参改成 <code>i+1</code> 就可以了。</p></li><li><p><strong>结果不能出现重复</strong></p><p>细心的小同学，可能已经发现了，“诶？这个问题不是在<strong>全排列 2</strong> 中解决过嘛？”</p><p>没错，直接把<strong>全排列 2</strong> 中的那个剪枝拿过来就可以了（“拿来” 主义狂喜～）。</p></li></ol><h3 id="code-4"><a class="anchor" href="#code-4">#</a> Code</h3><p>为了节省码字时间和文章空间，本题就不放完整代码了，正好读者可以自己试试能不能写出来。</p><p>下面写出两个关键点的实现，其余的代码和上一题 “组合总和”<strong> 完全相同</strong>。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> 循环 <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 剪枝。全排列 2 的思路：对于重复数字直接跳过就可以啦。</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> start <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// do something~~</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 递归。数字不可以重复使用。</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 撤销 do something~~</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="leetcode-77-组合"><a class="anchor" href="#leetcode-77-组合">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb25zLw==">LeetCode 77. 组合</span></h2><blockquote><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>你可以按 任何顺序 返回答案。</p><p>输入：n = 4, k = 2<br>输出：<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p></blockquote><h3 id="思路及实现-4"><a class="anchor" href="#思路及实现-4">#</a> 思路及实现</h3><p>对比其它题目，本题有两个关键点：</p><ol><li><p><strong>递归结束条件，不在是排列完 n 个数，而是排列完 k 个数</strong></p><p>解决该问题，很简单，直接换一下递归结束条件即可。</p></li><li><p><strong>从示例中可以看出，最终结果中，数字相同的组合即便顺序不同也不能存在，比如：[1,2],[2,1] 属于一种。</strong></p><p>这个问题其实也不难，思考一下，其中的搜索顺序是从前往后搜索，而<strong>对于已经搜索完的位置是不需要重复搜索的</strong>，注意体会上一句话，为什么搜索完的位置不需要重复搜索呢？</p><p>以 <code>n=4,k=2</code> 为例，显然，会先搜索出由 <code>1</code> 开头的 [[1,2],[1,3],[1,4]]（搜索够两个数就回溯了，比如搜索出 [1,2]，就回到 [1]，然后搜索出 [1,3]），现在，请注意，当我们搜索由 <code>2</code> 开头的路径的时候，不需要再搜索 [2,1] 了，同时 [2,2] 也是不合法的，因为每个数字只能用一次，也就是从 <code>2</code> 的下一个数 <code>3</code> 开始搜索就可以了。</p><p>那么，如何能让递归搜索的时候，搜索下一个数呢？</p><p>很显然，这就对上了<strong>组合总和</strong>中所讲的 <code>start</code> 的作用。</p></li></ol><h3 id="code-5"><a class="anchor" href="#code-5">#</a> Code</h3><p>同样给出部分与其他题目不同的地方的实现，读者可以自己补充全 (好像基本也全写出来了 😅)。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 递归结束条件</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        k <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        k <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">//dfs 函数初始化</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="leetcode-78-子集"><a class="anchor" href="#leetcode-78-子集">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3Vic2V0cy8=">LeetCode 78. 子集</span></h2><blockquote><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p></blockquote><h3 id="思路及实现-5"><a class="anchor" href="#思路及实现-5">#</a> 思路及实现</h3><p>对比其他题目，本题有一个明显与其他题目不同的关键点：</p><ol><li><p><strong>没有明显的递归终止条件</strong></p><p>在上一道题（77. 组合）中，递归终止条件由题目给出，既 k=0 时候，递归终止。而递归终止也就意味着，把当前路径 path 放到最终结果 res 中。</p><p>而本题，没有这个条件，怎么办？选择什么样的时机把当前路径 path 放到最终结果 res 呢？</p><p>认真观察给出的示例，可以得到答案：<br><strong>每次递归都把 path 放到 res</strong></p></li></ol><p>如果认真观察，我们本文中讲过的每一道题目，其实递归中止（或者叫开始回溯）的方式都有两个：</p><ol><li>明显的是：满足递归终止条件之后的 return。</li><li>不明显的是：每当 for 循环全部执行完毕之后，递归也会终止。</li></ol><p>而本题就要使用<strong>不明显的结束循环的方式进行回溯</strong>。<br><img data-src="/assets/3817494e-dcd0-44f8-bf18-46b0556b550a.png" alt=""></p><p>上图中的 dfs (0)，表示下一次搜索的位置，也就是 start。并且从上图中也能较清晰的看出，我们把每次递归到下一层的数字都存到当前路径，自然而然的就得到了所有子集，既 <code>[1],[1,2],[1,2,3],[1,3],[2]....</code> 。</p><h3 id="code-6"><a class="anchor" href="#code-6">#</a> Code</h3><p>实现方面就非常的简单了，只要把递归结束条件去掉就行了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="把-dfs-搜索扩展到其他类似题型"><a class="anchor" href="#把-dfs-搜索扩展到其他类似题型">#</a> 把 dfs 搜索扩展到其他类似题型</h1><h2 id="leetcode-22-括号生成"><a class="anchor" href="#leetcode-22-括号生成">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZ2VuZXJhdGUtcGFyZW50aGVzZXM=">LeetCode 22. 括号生成</span></h2><blockquote><p>数字 n  代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>输入：n = 3<br>输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</p></blockquote><h3 id="思路及实现-6"><a class="anchor" href="#思路及实现-6">#</a> 思路及实现</h3><p>对比其他题目，本题变化就比较大了，以至于可能无法一眼看出，本题需要用回溯来搞定，这是因为我们要先找出其中<strong>括号生成的规律。</strong></p><ol><li>为了使括号合法，我们应该先<strong>生成左括号</strong>。（这看起来似乎是一句废话，却是后面规律的基础。）</li><li>根据题目条件：<strong>总共需要生成 n 对括号</strong>，我们可以知道左括号的生成个数小于等于 n。换一句话说，<strong>只要左括号的数量没有达到 n，我们就可以生成左括号。</strong></li><li>根据题目条件：<strong>有效的括号组合</strong>，我们可以知道，<strong>右括号的数量应该总是小于等于左括号的数量。</strong></li><li>综上，我们可以得到递归的终止条件：<strong>当有 n 个左括号，并且右括号的数量与左括号相等（即也是 n 个）即说明我们找到了一种组合方式。</strong></li></ol><h3 id="code-7"><a class="anchor" href="#code-7">#</a> Code</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">//l, r 分别表示左右括号数量，cur 表示当前的字符串</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> string cur<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 递归结束条件</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> n <span class="token operator">&amp;&amp;</span> l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">return</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 左括号数量不够</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> cur <span class="token operator">+</span> <span class="token string">"("</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> l<span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cur <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="本题需要注意的点"><a class="anchor" href="#本题需要注意的点">#</a> 本题需要注意的点</h3><ol><li><p>为何不需要撤销操作呢？</p><p>注意看，我们选择路径用的是 cur 并非是全局变量，而是每个函数的独有参数。</p><p>例如：当我们递归到 dfs (2, 0, &quot;((&quot;, n) 的时候本层的参数 cur 就是 &quot;((&quot;，这是已经固定的，等我们在回溯到第二层的时候，cur 依旧是 &quot;((&quot;。</p></li><li><p>本题使用的依旧是<strong>不明显的回溯方式</strong>，即循环结束回溯。</p></li><li><p>本题通过最后一行代码进行递归，所以回溯的时候，也是连续回溯的。即：“((()))” 会直接回溯到 “((” 才开始下一轮递归。</p><p>因为当 “((()))” 回溯到 “((())” 的时候，会发现 “((())” 对应的函数也<strong>执行结束</strong>了，那么就会又回溯到上一层，直到回溯到一个<strong>没有直接执行结束的函数</strong>，从这个函数开始下一轮递归。</p></li></ol><h2 id="leetcode-200-岛屿数量"><a class="anchor" href="#leetcode-200-岛屿数量">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbnVtYmVyLW9mLWlzbGFuZHM=">LeetCode 200. 岛屿数量</span></h2><blockquote><p>给你一个由  '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和 / 或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>输入：grid = [<br>[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],<br>[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],<br>[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],<br>[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]<br>]<br>输出：1</p></blockquote><h3 id="思路及实现-7"><a class="anchor" href="#思路及实现-7">#</a> 思路及实现</h3><p>乍一看这题好像和前面的题没有什么关系，但其实理解题意后会发现，这也是一道搜索题目。</p><p>首先理解一下本题的题意：</p><p><strong>横竖连接起来的 1 (陆地) 表示岛屿（斜着不行），而 0 表示海水，问有多少个岛屿。</strong></p><p>通过示例来看，其实就是问由 1 横竖连接起来的块有几个，示例中是 1 个，既，如下图所示。<br><img data-src="/assets/e2ed3b0f-e0e3-472d-b3c3-634536b542a1.png" alt=""></p><p>那么，如何来进行判断呢？通过本小节的标题，其实读者应该也能判断出来，主要还是<strong>按照顺序搜索</strong>。</p><p>具体的：</p><ol><li>我们从左上角开始搜索，遇到 1 就说明找到了一个岛屿，并且开始 dfs。</li><li>dfs 时向四个方向扩展，而可以扩展到的 1，就说明是与当前岛屿是一体的，因此把他们变成海水（0），<strong>避免 组成当前岛屿的陆地 被重复搜索。</strong></li><li>用这种搜索方式，我们就可以找到所有的岛屿。</li></ol><h3 id="code-8"><a class="anchor" href="#code-8">#</a> Code</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                    res <span class="token operator">++</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span> <span class="token comment">// 搜索过的陆地变成海水，防止再搜索</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 向四个方向搜索</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token keyword">int</span> a <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token comment">// 跳过出界的格子</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> a <span class="token operator">>=</span> n <span class="token operator">||</span> b <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> b <span class="token operator">>=</span> m<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token comment">// 跳过海水</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'0'</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token comment">// 向下搜索</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token function">dfs</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="leetcode-51-n-皇后"><a class="anchor" href="#leetcode-51-n-皇后">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbi1xdWVlbnMv">LeetCode 51. N 皇后</span></h2><blockquote><p>n  皇后问题 研究的是如何将 n  个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的  n  皇后问题 的解决方案。</p><p>每一种解法包含一个不同的  n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。</p><p>输入：n = 4<br>输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</p><p>解释：如上图所示，4 皇后问题存在两个不同的解法。</p></blockquote><h3 id="思路及实现-8"><a class="anchor" href="#思路及实现-8">#</a> 思路及实现</h3><p>n 皇后问题，也是特别经典的回溯问题，我可以按行进行搜索，对于每一行的每个格子，都判断它能不能放棋子。</p><h3 id="用全排列的思路进行分析"><a class="anchor" href="#用全排列的思路进行分析">#</a> 用全排列的思路进行分析</h3><p>请注意，这个搜索场景是不是和基础的全排列十分相似呢？</p><p>全排列中按照 <code>每个数字</code> 进行搜索，<strong>用每个数字和剩下的数字排列</strong>。</p><p>而 n 皇后用 <code>行</code> 进行搜索，<strong>对每行的每个格子都判断是否能放棋子</strong>。</p><p>而两题的区别也是比较明显的：</p><ol><li>在全排列中<strong>非重复的数字就可以被扩展到</strong>，因此我们用<strong>一个数组 st 来存储数字是否被用过</strong>；</li><li>而在 n 皇后中需要<strong>这个格子的所在列以及所在正反对角线没有皇后才可以扩展到</strong>，这就意味着我们需要<strong>三个用来判重的数组，分别存储当前格子所在列及正反对角线是否被占用</strong>，以此来判断当前格子能不能放棋子；</li></ol><p>进一步分析，就来到了本题<strong>最难</strong>的点：<strong>如何放置一个棋子之后，把该棋子的正反对角线也全部置为已经占用呢？</strong></p><p>要解决这个问题，我们先看一下对于某一列是如何置为被占用呢？</p><p>直接用一个判重数组 (col) 就可以了，比如：col [1]，就表示第二列已经被占用了，假设当前是第 3 行，下次递归到第 4 行，在第 4 行判断第二列的时候，也要用 col [1]，发现已经是 true，既被占用。</p><p>用伪代码表示这一过程：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> col<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">dfs</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        col<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>到了对角线这里，可以使用 <code>行坐标+列坐标（即u+i）</code> 来判断对角线位置是否被占用，我们把棋盘放在坐标系上：<br><img data-src="/assets/7b216432-82d4-48a7-aee4-f4bc2100636e.png" alt=""></p><p>当我们选择点 x (2,1) 放棋子的时候，那么它的两条对角线就不能再放了，用红绿色线标识过点 x 的两条对角线，可以直观的看到其中<strong>绿色对角线的横纵坐标之和总是相等的</strong>；而<strong>红色对角线的坐标之差总是相等的</strong>。</p><p>然后把三个判重数组带入到板子中，替换掉 st 数组。</p><h3 id="code-9"><a class="anchor" href="#code-9">#</a> Code</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> path<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> col<span class="token punctuation">,</span> dg<span class="token punctuation">,</span> udg<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> _n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        n <span class="token operator">=</span> _n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        col <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        dg <span class="token operator">=</span> udg <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        path <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 其中 u 表示枚举 行</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 结束条件</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">return</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 循环 列</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// 判重</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>col<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>dg<span class="token punctuation">[</span>u <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>udg<span class="token punctuation">[</span>u <span class="token operator">-</span> i <span class="token operator">+</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                path<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'Q'</span><span class="token punctuation">;</span> <span class="token comment">// 放棋子</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token comment">// 其中 u-i+n 是为了避免出现负数，其中 n 是多少无所谓。</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                col<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dg<span class="token punctuation">[</span>u <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> udg<span class="token punctuation">[</span>u <span class="token operator">-</span> i <span class="token operator">+</span> n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token comment">// 回溯</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                col<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dg<span class="token punctuation">[</span>u <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> udg<span class="token punctuation">[</span>u <span class="token operator">-</span> i <span class="token operator">+</span> n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                path<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'.'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="acwing-165-小猫爬山"><a class="anchor" href="#acwing-165-小猫爬山">#</a> <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTY3Lw==">AcWing 165. 小猫爬山</span></h2><blockquote><p>翰翰和达达饲养了 N 只小猫，这天，小猫们要去爬山。</p><p>经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕 &gt;_&lt;）。</p><p>翰翰和达达只好花钱让它们坐索道下山。</p><p>索道上的缆车最大承重量为 W，而 N 只小猫的重量分别是 C1、C2……CN。</p><p>当然，每辆缆车上的小猫的重量之和不能超过 W。</p><p>每租用一辆缆车，翰翰和达达就要付 1 美元，所以他们想知道，最少需要付多少美元才能把这 N 只小猫都运送下山？</p><p>输入格式</p><p>第 1 行：包含两个用空格隔开的整数，N 和 W。</p><p>第 2..N+1 行：每行一个整数，其中第 i+1 行的整数表示第 i 只小猫的重量 Ci。</p><p>输出格式</p><p>输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。</p><p>数据范围</p><p>1≤N≤18,<br>1≤Ci≤W≤10^8</p></blockquote><h3 id="思路及实现-9"><a class="anchor" href="#思路及实现-9">#</a> 思路及实现</h3><p>先来看下基本的题意：有 n 只小猫重量是 Ci，有称重量为 W 的缆车，问我们要用多少辆缆车，才能装下所有的小猫。</p><p>从本题的数据范围来看，N 特别小而 Ci 和 W 特别大，所以使用回溯枚举出所有搜搜方式来解决。</p><ol><li><p>而搜索问题，我们就要<strong>考虑搜索顺序</strong>了。</p><p>从题意上来看，对于每只小猫咪都可能有两种决策：</p><ol><li><p>如果不会超重，就可以放到一个已有的缆车里，递归放下一只猫咪；</p></li><li><p>如果已有缆车都不能放，选择一辆新的缆车，递归放下一只猫咪；</p></li><li><p>使用这两种放置方式，最终我们会枚举出所有的放置方式，自然也就能找到使用缆车最少的那种方式。</p></li></ol></li><li><p>接下来，我们<strong>如何找到使用最少缆车的方案呢？</strong></p><p>(为了区分递归中的过程和结果，下面把搜索过程中产生的方案称为<strong>路径</strong>，把所有猫咪全安排好后的产生的结果称为<strong>方案</strong>，每个方案都是使用的缆车数。)</p><p>可以把 “使用缆车个数” 作为递归参数，每次在递归的时候判断如果<strong>当前路径</strong>大于等于<strong>当前最优方案</strong>，那么就可以直接回溯了，这样当我们枚举完所有猫咪，如果还没回溯，当前路径自然就是新的最优方案了。</p></li><li><p>请注意，既然在第二步已经设置了剪枝：大于当前最优方案直接回溯，那么我们可以进行进一步剪枝，既<strong>把猫咪按照重量从大到小排序。</strong></p><p>思考一下，为什么可以这样呢？在最初的<strong>全排列</strong>中，我们就已经知道不断的递归回溯，最后会形成递归树，而树的分支越少就证明搜索的越快。</p><p>那么当我们设置了，<strong>当前路径</strong>大于等于<strong>当前最优方案</strong>就回溯的时候，我们<strong>只要按照最大重量的猫咪开始搜索</strong>，这样占用的缆车承重就是<strong>比较大</strong>的，所以剩余的承重就变小了，可选择的猫咪也就变少了，树的分支也就变少啦～</p></li></ol><h3 id="code-10"><a class="anchor" href="#code-10">#</a> Code</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> cat<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//sum 存储每个缆车的重量</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> n<span class="token punctuation">,</span> w<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> res <span class="token operator">=</span> N<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 当前路径大于等于当前最优方案，</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 没必要再搜索了直接回溯</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">>=</span> res<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 搜索完所有小猫咪而没有回溯</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 当前方案则比最优方案更好。</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        res <span class="token operator">=</span> k<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">// 枚举每辆缆车，注意这里枚举的是缆车，而不是猫咪。</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 如果说放当前猫咪不会超重，就放到缆车 i。</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cat<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> cat<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> cat<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token comment">// 新开一个缆车，</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    sum<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> cat<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    sum<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    cin <span class="token operator">>></span> n <span class="token operator">>></span> w<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> cin <span class="token operator">>></span> cat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token function">sort</span><span class="token punctuation">(</span>cat<span class="token punctuation">,</span> cat <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token function">reverse</span><span class="token punctuation">(</span>cat<span class="token punctuation">,</span> cat <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>回溯问题的本质就是一种全搜索，我们一般称之为爆搜，简言之就是暴力的搜索出所有可能的情况，从而找到一种需要的结果。</p><p>我们在基础例题全排列中，给出了一个较为通用的模板，在实际应用当中，读者应熟练应用该模板，根据不同的题目灵活完成模板的每个步骤。比如：</p><ol><li><strong>全排列</strong>中要求每个数字不能重复使用，我们就使用一个数组来进行判重；</li><li><strong>组合总和</strong>中数字可以重复使用，就用 start 参数来做标记，每次从上一层最后被搜索的数字开始搜索；</li><li><strong>组合</strong>中要求 k 个数字的不同组合，因此在递归结束条件中，只要搜索到 k 个数，就开始回溯；</li><li><strong>括号生成</strong>中的搜索使用了 “不明显的回溯”，即函数执行结束回溯；</li><li><strong>岛屿数量</strong>中因为只需要一路向下搜索（递归），搜索完整个图就可以了，而不需要回溯。</li><li><strong>N 皇后</strong>是非常经典的题目，根据其规则，我们要把判重数组扩充到三个；</li><li><strong>小猫爬山</strong>中至关重要的是搜索的顺序以及剪枝；</li></ol><p>另外，回溯的时间复杂度一直没有提到，这是因为回溯问题因为要搜索出所有可行的方案，所以时间复杂度很高，会达到 O (n!)，而通过不同的剪枝，又会极大降低时间复杂度，因此回溯问题的时间复杂度会随着剪枝和数据范围的变化而变化。</p><p>但是，可以肯定的是，因为基础时间复杂度很高，所以需要使用回溯的问题<strong>数据范围一般都很小</strong>，读者可以关注一下上面题目中的数据范围，例如：小猫爬山的 N 只有 18。</p><p>也因此，当遇到数据范围较小的问题时，我们可以考虑一下是否可以使用回溯，暴力的求出所有可能的方案，从其中找到答案。</p><p>面对回溯问题，我们一般需要考虑的是：</p><ol><li>确定递归结束的条件（何时开始回溯？）</li><li>通过什么样的顺序搜索？</li><li>是否需要回溯（考虑是否使用了全局变量更新状态）？</li><li>是否需要剪枝？</li><li>前面四步考虑清楚，尝试着带入到模板就可以啦～～</li></ol><p><strong>ENG</strong></p><div class="tags"><a href="/tags/LeetCode/" rel="tag"><i class="ic i-tag"></i> LeetCode</a> <a href="/tags/AcWing/" rel="tag"><i class="ic i-tag"></i> AcWing</a> <a href="/tags/%E7%BB%8F%E5%85%B8%E5%BF%85%E4%BC%9A/" rel="tag"><i class="ic i-tag"></i> 经典必会</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/" rel="tag"><i class="ic i-tag"></i> 深度优先搜索(DFS)</a> <a href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag"><i class="ic i-tag"></i> 回溯</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-07-04 17:41:31" itemprop="dateModified" datetime="2022-07-04T17:41:31+08:00">2022-07-04</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/wechatpay.png" alt="A Cat Without Sugar 微信支付"><p>微信支付</p></div><div><img data-src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/alipay.png" alt="A Cat Without Sugar 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>A Cat Without Sugar <i class="ic i-at"><em>@</em></i>小猫咪吃python</li><li class="link"><strong>本文链接：</strong> <a href="http://yoursite.com/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%94%BB%E7%95%A5/" title="看完必会的回溯算法入门攻略">http://yoursite.com/看完必会的回溯算法入门攻略/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E9%97%AE%E9%A2%98(%E4%BA%8C)/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclimtf7dj20zk0m8qav.jpg" title="有趣的博弈论问题(二)"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 数学</span><h3>有趣的博弈论问题(二)</h3></a></div><div class="item right"><a href="/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%A5%E9%97%A8%E6%94%BB%E7%95%A5/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclimtf7dj20zk0m8qav.jpg" title="看完必会的滑动窗口入门攻略"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 数据结构</span><h3>看完必会的滑动窗口入门攻略</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">回溯的含义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E5%85%A8%E6%8E%92%E5%88%97%E5%BC%80%E5%A7%8B"><span class="toc-number">2.</span> <span class="toc-text">从 “全排列” 开始</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">2.1.</span> <span class="toc-text">LeetCode 46. 全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.1.</span> <span class="toc-text">简单的思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%98%AF%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.2.</span> <span class="toc-text">回溯是在做什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code"><span class="toc-number">2.1.3.</span> <span class="toc-text">Code</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%AA%E6%9D%BF%E5%AD%90"><span class="toc-number">3.</span> <span class="toc-text">总结个 “板子”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9D%BF%E5%AD%90%E8%A7%A3%E5%86%B3%E5%90%8C%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE"><span class="toc-number">4.</span> <span class="toc-text">使用 “板子” 解决同类型题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode-47-%E5%85%A8%E6%8E%92%E5%88%97-ii"><span class="toc-number">4.1.</span> <span class="toc-text">LeetCode 47. 全排列 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">思路及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-2"><span class="toc-number">4.1.2.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">4.2.</span> <span class="toc-text">LeetCode 39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.2.1.</span> <span class="toc-text">思路及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-3"><span class="toc-number">4.2.2.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii"><span class="toc-number">4.3.</span> <span class="toc-text">LeetCode 40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">4.3.1.</span> <span class="toc-text">思路及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-4"><span class="toc-number">4.3.2.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode-77-%E7%BB%84%E5%90%88"><span class="toc-number">4.4.</span> <span class="toc-text">LeetCode 77. 组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">4.4.1.</span> <span class="toc-text">思路及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-5"><span class="toc-number">4.4.2.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode-78-%E5%AD%90%E9%9B%86"><span class="toc-number">4.5.</span> <span class="toc-text">LeetCode 78. 子集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">4.5.1.</span> <span class="toc-text">思路及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-6"><span class="toc-number">4.5.2.</span> <span class="toc-text">Code</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%8A-dfs-%E6%90%9C%E7%B4%A2%E6%89%A9%E5%B1%95%E5%88%B0%E5%85%B6%E4%BB%96%E7%B1%BB%E4%BC%BC%E9%A2%98%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">把 dfs 搜索扩展到其他类似题型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">5.1.</span> <span class="toc-text">LeetCode 22. 括号生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">5.1.1.</span> <span class="toc-text">思路及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-7"><span class="toc-number">5.1.2.</span> <span class="toc-text">Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E9%A2%98%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">5.1.3.</span> <span class="toc-text">本题需要注意的点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">LeetCode 200. 岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">5.2.1.</span> <span class="toc-text">思路及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-8"><span class="toc-number">5.2.2.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode-51-n-%E7%9A%87%E5%90%8E"><span class="toc-number">5.3.</span> <span class="toc-text">LeetCode 51. N 皇后</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0-8"><span class="toc-number">5.3.1.</span> <span class="toc-text">思路及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E6%80%9D%E8%B7%AF%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90"><span class="toc-number">5.3.2.</span> <span class="toc-text">用全排列的思路进行分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-9"><span class="toc-number">5.3.3.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#acwing-165-%E5%B0%8F%E7%8C%AB%E7%88%AC%E5%B1%B1"><span class="toc-number">5.4.</span> <span class="toc-text">AcWing 165. 小猫爬山</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0-9"><span class="toc-number">5.4.1.</span> <span class="toc-text">思路及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-10"><span class="toc-number">5.4.2.</span> <span class="toc-text">Code</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%94%BB%E7%95%A5/" rel="bookmark" title="看完必会的回溯算法入门攻略">看完必会的回溯算法入门攻略</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="A Cat Without Sugar" data-src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/avatar.jpg"><p class="name" itemprop="name">A Cat Without Sugar</p><div class="description" itemprop="description">孤独与剑，自由与酒</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">21</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">29</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E9%97%AE%E9%A2%98(%E4%BA%8C)/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%A5%E9%97%A8%E6%94%BB%E7%95%A5/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/AcWing%20240.%20%E9%A3%9F%E7%89%A9%E9%93%BE%EF%BC%88%E8%B6%85%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86%E9%A2%98%E7%9B%AE%EF%BC%89/" title="AcWing 240. 食物链（超有趣的并查集题目）">AcWing 240. 食物链（超有趣的并查集题目）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%A5%E9%97%A8%E6%94%BB%E7%95%A5/" title="看完必会的滑动窗口入门攻略">看完必会的滑动窗口入门攻略</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/" title="分类于 数学">数学</a></div><span><a href="/%E7%A5%9E%E5%A5%87%E7%9A%84%E5%BF%AB%E9%80%9F%E5%B9%82/" title="神奇的快速幂">神奇的快速幂</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/" title="分类于 数学">数学</a></div><span><a href="/%E4%BB%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86--%E8%B4%A8%E6%95%B0/" title="从代码的角度重新认识--质数">从代码的角度重新认识--质数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="有趣的数据结构-二叉堆的实现">有趣的数据结构-二叉堆的实现</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/" title="分类于 数学">数学</a></div><span><a href="/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E9%97%AE%E9%A2%98(%E4%BA%8C)/" title="有趣的博弈论问题(二)">有趣的博弈论问题(二)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="分类于 动态规划">动态规划</a></div><span><a href="/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%9A%84%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96/" title="多重背包的终极优化">多重背包的终极优化</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="分类于 动态规划">动态规划</a></div><span><a href="/LeetCode%20691.%20%E8%B4%B4%E7%BA%B8%E6%8B%BC%E8%AF%8D%EF%BC%88%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%88%86%E6%90%9C%EF%BC%89/" title="LeetCode 691. 贴纸拼词">LeetCode 691. 贴纸拼词</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" title="分类于 搜索与图论">搜索与图论</a></div><span><a href="/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%94%BB%E7%95%A5/" title="看完必会的回溯算法入门攻略">看完必会的回溯算法入门攻略</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/" title="分类于 数学">数学</a></div><span><a href="/%E6%9C%89%E8%B6%A3%E7%9A%84%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/" title="有趣的欧拉函数">有趣的欧拉函数</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">A Cat Without Sugar @ The Cat to eat Python</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"看完必会的回溯算法入门攻略/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/js/app.js?v=0.2.5"></script></body></html>