<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="小猫咪吃python" href="http://yoursite.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="小猫咪吃python" href="http://yoursite.com/atom.xml"><link rel="alternate" type="application/json" title="小猫咪吃python" href="http://yoursite.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/css/app.css?v=0.2.5"><meta name="keywords" content="LeetCode,前缀和,单调队列,二分,AcWing算法提高课"><link rel="canonical" href="http://yoursite.com/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP%E6%94%BB%E7%95%A5/"><title>看完必会的单调队列优化DP攻略 - 动态规划 - 算法 | The Cat to eat Python = 小猫咪吃python = 唤起一天明月 照我满怀冰雪 浩荡百川流 鲸饮未吞海 剑气已横秋</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">看完必会的单调队列优化DP攻略</h1><div class="meta"><span class="item" title="创建时间：2022-07-22 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-07-22T00:00:00+08:00">2022-07-22</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>10k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>9 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">The Cat to eat Python</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclffsa1cj20zk0m811l.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicitf0kl1j20zk0m87fe.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciuv0socj20zk0m8qes.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicliierfjj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="item" rel="index" title="分类于 算法"><span itemprop="name">算法</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="item" rel="index" title="分类于 动态规划"><span itemprop="name">动态规划</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://yoursite.com/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP%E6%94%BB%E7%95%A5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/avatar.jpg"><meta itemprop="name" content="A Cat Without Sugar"><meta itemprop="description" content="唤起一天明月 照我满怀冰雪 浩荡百川流 鲸饮未吞海 剑气已横秋, 孤独与剑，自由与酒"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小猫咪吃python"></span><div class="body md" itemprop="articleBody"><blockquote><p>前置知识：<span class="exturl" data-url="aHR0cHM6Ly9janJ6cy5naXRodWIuaW8vJUU3JTlDJThCJUU1JUFFJThDJUU1JUJGJTg1JUU0JUJDJTlBJUU3JTlBJTg0JUU2JUJCJTkxJUU1JThBJUE4JUU3JUFBJTk3JUU1JThGJUEzJUU1JTg1JUE1JUU5JTk3JUE4JUU2JTk0JUJCJUU3JTk1JUE1Lw==">滑动窗口</span>，<span class="exturl" data-url="aHR0cHM6Ly9janJ6cy5naXRodWIuaW8vJUU1JUFFJTlFJUU3JTk0JUE4JUU3JTlBJTg0JUU3JUFFJTk3JUU2JUIzJTk1JUU1JUIwJThGJUU2JThBJTgwJUU1JUI3JUE3LS0lRTUlODklOEQlRTclQkMlODAlRTUlOTIlOEMv">前缀和</span>。这两个基本技巧是本文涉及题目的基础，应优先掌握。</p></blockquote><h1 id="单调队列优化"><a class="anchor" href="#单调队列优化">#</a> 单调队列优化</h1><p>在动态规划的世界中，有那么一个小部落，这个部落里的题目都具有某些相同的特征：<strong>在状态转移的部分，上一状态的取值范围是一个给定大小的窗口，而我们要维护窗口中元素的某种极值作为上一状态，此时就可以使用单调队列来维护滑动窗口的极值</strong>。</p><p>尤其值得注意的一点是，这类的题目中通常伴随着 “<strong>连续</strong>”、“<strong>子序列</strong>” 等关键词。</p><h1 id="acwing-135-最大子序和"><a class="anchor" href="#acwing-135-最大子序和">#</a> <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTM3Lw==">AcWing 135. 最大子序和</span></h1><blockquote><p>输入一个长度为 n 的整数序列，从中找出一段长度不超过 m 的连续子序列，使得子序列中所有数的和最大。</p><p>注意： 子序列的长度至少是 1。</p><p><strong>输入格式</strong><br>第一行输入两个整数 n,m。</p><p>第二行输入 n 个数，代表长度为 n 的整数序列。</p><p>同一行数之间用空格隔开。</p><p><strong>输出格式</strong><br>输出一个整数，代表该序列的最大子序和。</p><p><strong>数据范围</strong><br>1≤n,m≤300000</p><p><strong>输入样例</strong><br>6 4<br>1 -3 5 1 -2 3<br><strong>输出样例</strong><br>7</p></blockquote><h2 id="题目描述"><a class="anchor" href="#题目描述">#</a> 题目描述</h2><p><strong>在长度为 n 的一个整数序列中找出一段不超过 m 长度的子序列</strong>，这里需要注意的是子序列意味着不可以跳着选，长度为 m 的子序列必须是连续的。而最后输出的是<strong>子序列中所有元素和最大</strong>的子序列。</p><h2 id="题目示例"><a class="anchor" href="#题目示例">#</a> 题目示例</h2><p>在长度为 6 的序列找出长度<strong>不超过 4</strong> 的子序列，使得<strong>该子序列的和</strong>最大。</p><p>我们看下给出示例中的子序列都有哪些呢？</p><pre><code>[1],[1,-3],[1,-3,5],[1,-3,5,1]
[-3],[-3,5],[-3,5,1],[-3,5,1,-2]
[5],[5,1],[5,1,-2],[5,1,-2,3]
[1],[1,-2],[1,-2,3]
[-2],[-2,3]
[3]
</code></pre><p>所以最后输出 <strong>和最大的子序列的和</strong>，也就是 <code>[5,1,-2,3]=7</code> 。</p><h2 id="题目分析"><a class="anchor" href="#题目分析">#</a> 题目分析</h2><ol><li><p>如果有对<strong>滑动窗口</strong>这种技巧有所了解的话，可以很快的发现，诶？这不就是<strong>长度最长为 m 的滑动窗口求极值问题</strong>吗？我们只要<strong>对每个窗口，都求出该窗口内所有元素的和，然后实时更新窗口和的最大值，当枚举完所有的元素，最后的那个最大值就是答案</strong>。</p></li><li><p>那么，<strong>如何快速求出一个窗口内所有元素的和呢？</strong> 关于这一点其实也有一个小技巧，即<strong>前缀和</strong>，它的作用就是在 O (1) 的时间内求出某个区间内所有元素的和。</p></li><li><p>我们知道求区间和的公式是 <code>sum[r] - sum[l-1]</code> ，也就是说，想让区间和越大，那么只需要让队列（窗口）头部元素最小就可以了。</p></li></ol><h2 id="code"><a class="anchor" href="#code">#</a> Code</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">300010</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 前缀和数组</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 单调队列求滑动窗口</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        cin <span class="token operator">>></span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 计算前缀和</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 在数组模拟队列的方法里，我们用 hh 表示队列头，用 tt 表示队列尾</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 一般来讲队列尾 tt 要初始化为 - 1，这里初始化为 0，是因为此时我们</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">// 默认队列中已经有一个元素，就是 0，对应前缀和的第一个元素 s [0]=0</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0x3f3f3f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 滑动窗口模板，窗口中队头保存当前的最小值</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> i <span class="token operator">-</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span> <span class="token operator">></span> m<span class="token punctuation">)</span> hh <span class="token operator">++</span> <span class="token punctuation">;</span> <span class="token comment">// 维护窗口大小不超过 m</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> s<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实时维护最大的子序列和</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 单调队列要维护最小值，那么当前元素比队尾还小，说明队尾元素没有价值了，出队即可。</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre>        q<span class="token punctuation">[</span><span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 把当前元素入队，注意这里队列中保存的是下标</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="acwing-1087-修剪草坪"><a class="anchor" href="#acwing-1087-修剪草坪">#</a> <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA4OS8=">AcWing 1087. 修剪草坪</span></h1><blockquote><p>在一年前赢得了小镇的最佳草坪比赛后，FJ 变得很懒，再也没有修剪过草坪。</p><p>现在，新一轮的最佳草坪比赛又开始了，FJ 希望能够再次夺冠。</p><p>然而，FJ 的草坪非常脏乱，因此，FJ 只能够让他的奶牛来完成这项工作。</p><p>FJ 有 N 只排成一排的奶牛，编号为 1 到 N。</p><p>每只奶牛的效率是不同的，奶牛 i 的效率为 Ei。</p><p>编号相邻的奶牛们很熟悉，如果 FJ 安排超过 K 只编号连续的奶牛，那么这些奶牛就会罢工去开派对。</p><p>因此，现在 FJ 需要你的帮助，找到最合理的安排方案并计算 FJ 可以得到的最大效率。</p><p>注意，方案需满足不能包含超过 K 只编号连续的奶牛。</p><p><strong>输入格式</strong><br>第一行：空格隔开的两个整数 N 和 K；</p><p>第二到 N+1 行：第 i+1 行有一个整数 Ei。</p><p><strong>输出格式</strong><br>共一行，包含一个数值，表示 FJ 可以得到的最大的效率值。</p><p><strong>数据范围</strong><br>1≤N≤10^5,<br>0≤Ei≤10^9</p><p><strong>输入样例</strong><br>5 2<br>1<br>2<br>3<br>4<br>5</p><p><strong>输出样例</strong><br>12</p><p><strong>样例解释</strong><br>FJ 有 5 只奶牛，效率分别为 1、2、3、4、5。</p><p>FJ 希望选取的奶牛效率总和最大，但是他不能选取超过 2 只连续的奶牛。</p><p>因此可以选择第三只以外的其他奶牛，总的效率为 1 + 2 + 4 + 5 = 12。</p></blockquote><h2 id="题目描述-2"><a class="anchor" href="#题目描述-2">#</a> 题目描述</h2><p>同上题类似，给出一个长度为 n 的序列 s，要从中选择出一些元素使得最后这些<strong>被选择元素的和 最大</strong>，然而给出了一个规则，<strong>不能选择连续超过 m 个元素</strong>。</p><h2 id="题目分析-2"><a class="anchor" href="#题目分析-2">#</a> 题目分析</h2><p>如果我们不知道文章题目而是实际中遇到这题，看到题目中有<strong>安排方案</strong>这种关键字，也是首先应该考虑是否可以<strong>动态规划</strong>或者<strong> DFS</strong>，看本题的<strong>数据范围</strong>，DFS 可能会超时，所以我们优先选择动态规划。</p><p>其实大家也能感觉到，本题和上一个题目非常类似，但仍有一些区别，本题的目标是<strong>从整个序列的所有元素中选出一些元素的最大和，而窗口大小 m 变成了一个选择过程中的限制条件</strong>，而上一题<strong>窗口大小 m</strong> 则是<strong>最终结果的限制条件</strong>。</p><h3 id="状态定义"><a class="anchor" href="#状态定义">#</a> 状态定义</h3><p><code>f(i)</code> 表示从以 <code>i</code> 为右端点的序列中选择，符合题目条件 并且 序列中 所有元素 和最大 的方案 的元素和。</p><h3 id="状态转移"><a class="anchor" href="#状态转移">#</a> 状态转移</h3><p>与其他动态规划问题相同，我们根据最后一个没有选择的元素对集合进行划分。根据题目范围我们知道每个元素都是正整数，也就是说最佳的方案中<strong>如果选择了超过 m 个元素，那么我们不选其中的一个，使选择的元素断开，一定不会使结果变坏</strong>。所以状态转移中，我们就枚举最后一个 “<strong>不选的元素 j</strong>”。</p><p>如此，<strong>最后一个 “不选择的元素 j”</strong> 将整个序列分成了两部分：</p><ol><li>第一部分是<strong>在以 <code>j-1</code> 为右端点的元素中做选择</strong>，我们神奇的发现这一部分其实就是状态的定义 f (j-1)。</li><li>第二部分是 <code>j~i</code> 这一段的区间和，而对于区间和，我们可以使用<strong>前缀和</strong>快速求出。</li></ol><p><img data-src="/assets/1a79fd18-330a-4285-b185-08ee23ecadc6.png" alt=""></p><p>最后，我们把两部分相加就得到了状态转移方程： <code>f[i]=max(f[j-1] + s[i] - s[j])</code> 。</p><p>我们把公式整理一下，因为前缀和 s [i] 是已知的，所以可以提出来，那么公式变成： <code>f[i]=s[i]+max(f[j-1] - s[j])</code> 。</p><p>而我们想让 <code>f[j-1]-s[j]</code> 是最大值，<strong>只需要让 <code>s[j]</code> 是最小值即可</strong>。</p><p>要维护 <code>s[j]</code> 为最小值，注意 j 的取值范围 <code>0 &lt;= i-j &lt;= m</code> ，也就是说这是 <code>j~i</code> 是一个最大为 m 的窗口，所以我们可以如上题一般<strong>使用单调队列来维护这个大小为 m 的窗口中的最小值</strong>。</p><h2 id="code-2"><a class="anchor" href="#code-2">#</a> Code</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 单个元素的值为 10^9，求前缀和会爆 int，所以用 long long 来存。</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL <span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">int</span> hh<span class="token punctuation">,</span> tt<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>LL s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//s 数组存储前缀和</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">//g 函数快速求出分析中的公式</span></pre></td></tr><tr><td data-num="14"></td><td><pre>LL <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">return</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 求前缀和</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 此处 单调队列的队头队尾与上题相同。</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token comment">// 枚举前缀和数组 滑动窗口模板 </span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token comment">// 队头存储的是使得当前窗口中的 g (q [hh]) 最大的元素下标</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> m<span class="token punctuation">)</span> hh <span class="token operator">++</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token comment">// 分析中的公式</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">g</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token comment">// 维护这个单调递增序列</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> <span class="token function">g</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token function">g</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> tt <span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        q<span class="token punctuation">[</span><span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="acwing-1089-烽火传递"><a class="anchor" href="#acwing-1089-烽火传递">#</a> <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA5MS8=">AcWing 1089. 烽火传递</span></h1><blockquote><p>烽火台是重要的军事防御设施，一般建在交通要道或险要处。</p><p>一旦有军情发生，则白天用浓烟，晚上有火光传递军情。</p><p>在某两个城市之间有 n 座烽火台，每个烽火台发出信号都有一定的代价。</p><p>为了使情报准确传递，在连续 m 个烽火台中至少要有一个发出信号。</p><p>现在输入 n,m 和每个烽火台的代价，请计算在两城市之间准确传递情报所需花费的总代价最少为多少。</p><p><strong>输入格式</strong><br>第一行是两个整数 n,m，具体含义见题目描述；</p><p>第二行 n 个整数表示每个烽火台的代价 ai。</p><p><strong>输出格式</strong><br>输出仅一个整数，表示最小代价。</p><p><strong>数据范围</strong><br>1≤m≤n≤2×105,<br>0≤ai≤1000</p><p><strong>输入样例</strong><br>5 3<br>1 2 5 6 2</p><p><strong>输出样例</strong><br>4</p></blockquote><h2 id="题目描述-3"><a class="anchor" href="#题目描述-3">#</a> 题目描述</h2><p>给出一个长度为 n 的序列，选出一些元素，使得最后这些被选择元素之和最小，选择的要求是连续 m 个元素中至少要选择一个。</p><p>本题和上一题整好相反，上一题是<strong>所有被选择元素和最大，不能连续选择 m 个</strong>，而本题是<strong>所有被选择元素和最小，连续 m 个元素中至少选择一个</strong>。</p><h2 id="题目分析-3"><a class="anchor" href="#题目分析-3">#</a> 题目分析</h2><p>因为和上题类似，所以我们可以使用相同的动态规划思路。</p><h3 id="状态定义-2"><a class="anchor" href="#状态定义-2">#</a> 状态定义</h3><p><code>f(i)</code> 表示从以 <code>i</code> 为结尾的序列中选择，符合条件（ <code>m</code> 个元素中必选一个）并且选择元素 <code>i</code> 的 方案中，最优方案的 元素和。</p><h3 id="状态转移-2"><a class="anchor" href="#状态转移-2">#</a> 状态转移</h3><p>与上题类似，本题的状态转移中，我们枚举 i 之前 最后被选择的元素 j，以此 将整个序列分为两部分：</p><ol><li>一部分是 <code>1~j</code> ，这部分在 以 <code>j</code> 为结尾的序列中考虑，并且选择 <code>j</code> 的最优方案，我们神奇的发现这部分正好可以套在状态定义中，也就是 <code>f(j)</code> 。</li><li>另一部分是 <code>j~i</code> ，这段长度最长为 <code>m</code> 的序列中选择出的 <code>i</code> 的权重。</li></ol><p>最后，我们把两部分加起来就是 <code>f[i]=min(f[j] + w[i])</code> 。</p><p>在这个公式里， <code>i</code> 的权重 <code>w[i]</code> 是已经固定的，那么想求到最小值就<strong>需要让 <code>f[j]</code> 越小越好。</strong></p><p>而我们知道题目要求 m 个元素必须选择一个，所以 i 和 j 之间的距离就是 <code>1~m</code> ，即 <code>1 &lt;= i - j &lt;= m</code> 这样。</p><p>也就是我们要快速找到的 <code>f[j]</code> 是<strong>最大长度为 m 的窗口内的最小值</strong>， 所以就可以<strong>使用单调队列，在最大为 m 的窗口中维护一个最小值</strong>。</p><h2 id="code-3"><a class="anchor" href="#code-3">#</a> Code</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">200010</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        cin <span class="token operator">>></span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">and</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> m<span class="token punctuation">)</span> hh <span class="token operator">++</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 分析中的公式 队头存储的是最小的 f [j]</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 维护 递减队列单调性</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">and</span> f<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>=</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        q<span class="token punctuation">[</span><span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1e9</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        res <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="acwing-1090-绿色通道"><a class="anchor" href="#acwing-1090-绿色通道">#</a> <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTA5Mi8=">AcWing 1090. 绿色通道</span></h1><blockquote><p>高二数学《绿色通道》总共有 n 道题目要抄，编号 1,2,…,n，抄第 i 题要花 ai 分钟。</p><p>小 Y 决定只用不超过 t 分钟抄这个，因此必然有空着的题。</p><p>每道题要么不写，要么抄完，不能写一半。</p><p>下标连续的一些空题称为一个空题段，它的长度就是所包含的题目数。</p><p>这样应付自然会引起马老师的愤怒，最长的空题段越长，马老师越生气。</p><p>现在，小 Y 想知道他在这 t 分钟内写哪些题，才能够尽量减轻马老师的怒火。</p><p>由于小 Y 很聪明，你只要告诉他最长的空题段至少有多长就可以了，不需输出方案。</p><p><strong>输入格式</strong><br>第一行为两个整数 n,t。</p><p>第二行为 n 个整数，依次为 a1,a2,…,an。</p><p><strong>输出格式</strong><br>输出一个整数，表示最长的空题段至少有多长。</p><p><strong>数据范围</strong><br>0&lt;n≤5×10^4,<br>0&lt;ai≤3000,<br>0&lt;t≤10^8</p><p><strong>输入样例</strong><br>17 11<br>6 4 5 2 5 3 4 5 2 3 4 5 2 3 6 3 5</p><p><strong>输出样例</strong><br>3</p></blockquote><h2 id="题目描述-4"><a class="anchor" href="#题目描述-4">#</a> 题目描述</h2><p>（为什么小 Y 同学要抄作业呢？他自己写不行吗？大家可不要学习他。）</p><p>给出长度为 <code>n</code> 的序列，序列中每个元素都有一个权重 <code>w[i]</code> ，再给出一个正整数 <code>m</code> ，求出一个方案<strong>使得所选元素的权重总和不超过 m，并且 所选元素 的 间距 越小越好</strong>，目标是输出<strong>选中方案的最大间距和</strong>。</p><h2 id="题目分析-4"><a class="anchor" href="#题目分析-4">#</a> 题目分析</h2><p>本题初步看上去可能没有什么头绪，但是细品一下，我们可以注意到题目中的重要的关键信息：所求目标为<strong>所有方案中 间距和 最短的 那个方案中最长的 间距和 是多少</strong>。</p><p>这种<strong>最长的。。。中找最短的。。。<strong>或者</strong>最大的。。。中找最小的</strong>或者<strong>最慢的。。。中找最快的。。。<strong>等关键字，正是提示我们题目</strong>可能 具有二段性</strong>，因此我们应该优先考虑是否可以进行<strong>二分</strong>。</p><p>而在本题中，我们可以在题目中发现一个明显的信息：<strong>题目的最终答案，也就是 最小的间距 一定可以使 所选的元素权重和 满足 m</strong></p><p>在此基础上，<strong>如果我们把最终答案增大，也就是空题变多，那么所选元素总和就会变得小于 m；而我们把这个答案变小，也就是选择元素多了，显然最后会大于 m</strong>。</p><p>而小于 m 说明还有时间能抄更多的作业，大于 m 显然是不满足题目要求的，所以只有等于 m 才是正好的。</p><p>因此，我们可以以<strong>空题段为 0</strong> 作为二分的下限，而<strong>空题段为所有元素</strong>作为二分的上限，假设二分后的结果（最大间距）是 <code>x</code> 。</p><p>这样，本题就变形成了<strong>在序列中选择一些元素，最长的选择间隔是 x（换句话说 x+1 个间隔中必选一个元素），使选择的 元素和 最小</strong>。这样一来，本题变得和上一道题一模一样。</p><p>而我们在求出最小的 元素和 之后，只需要在与 m 进行比较，看看这个 最小的元素和（也就是花费的时间）是否达到了 <code>m</code> ，如果没达到 <code>m</code> ，说明最大间距还可以减小；如果超过了说明需要增加最大间距。</p><h2 id="code-4"><a class="anchor" href="#code-4">#</a> Code</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">50010</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 单调队列优化 DP 同上题</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">bool</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">and</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> x<span class="token punctuation">)</span> hh <span class="token operator">++</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">and</span> f<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>=</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        q<span class="token punctuation">[</span><span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1e9</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">// 只需要找最后一个间隔就可以啦。</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">return</span> res <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> cin <span class="token operator">>></span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token comment">// 二分</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> l <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="模板"><a class="anchor" href="#模板">#</a> 模板</h1><p>到此为止，我们已经写了四道类似的题目，它们的共同特点是都使用了<strong>单调队列</strong>，因此我想可以总结出一个模板，来应对类似题目。</p><blockquote><p>该类题目，一般给出一个长度为 <code>n</code> 的序列，给出一个窗口大小 <code>m</code> ，根据窗口大小 <code>m</code> 求方案。同时，伴随着<strong>连续</strong>、<strong>子序列</strong>等关键词。</p></blockquote><h2 id="code-5"><a class="anchor" href="#code-5">#</a> Code</h2><figure class="highlight cpp"><figcaption data-lang="C++"><span>伪代码</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 注意这里默认了队列中已经有了第一个元素，即 q [0] = 0;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 枚举序列 要注意是否需要先做前缀和 因为单调队列一般会求区间</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 而如果需要求区间和 多半需要提前计算前缀和 </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 确保窗口范围在给定的大小 m 内 </span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 比较符号 根据枚举顺序确定 一般正向枚举就是小于号</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">and</span> i <span class="token operator">-</span> m <span class="token operator">&lt;</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">)</span> hh <span class="token operator">++</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 状态转移 其中极值在队列头 也就是 q [hh] </span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 确保队列单调性</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">and</span> <span class="token punctuation">&#123;</span>队尾q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span> 与 当前元素i 比较<span class="token punctuation">&#125;</span><span class="token punctuation">)</span> tt <span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    q<span class="token punctuation">[</span> <span class="token operator">++</span> tt <span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token comment">// 把当前元素放到队列，注意这里放的是下标</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">// 根据状态的定义 判断最后的目标值。</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// 如果是对整个序列求和之类的整体操作，那么多半可能是 f [n]。</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">// 如果是选择最佳方案之类的 则可能需要再在整个序列上找一下答案。</span></pre></td></tr></table></figure><h2 id="基本参数"><a class="anchor" href="#基本参数">#</a> 基本参数</h2><p><strong>f 数组</strong>：表示状态定义。在状态定义中，一般是<strong>以当前元素 <code>i</code> 为结尾的序列，同时满足题目条件，并且选择当前元素 i</strong>，</p><p><strong>q 数组</strong>： 用来配合 <code>hh</code> 和 <code>tt</code> 指针来模拟单调队列，值得注意的是：在模板中我们默认了队列拥有第一个元素 <code>0</code> ，并且在枚举的时候，也是从 <code>1</code> 开始枚举的（而不是 <code>0</code> ），因此，我们读入数据的时候最好也从下标 <code>1</code> 开始读入。</p><p><strong>w 数组</strong>：一般会存储题目给出的长度为 <code>n</code> 的序列，这里值得注意的是：单调队列的作用是<strong>在某个区间内维护极值</strong>，而关于区间的操作，我们就有可能会涉及到<strong>求区间和</strong>，而在 <code>O(1)</code> 的时间内求区间和，离不开<strong>前缀和</strong>的加持，因此，我们必须<strong>判断 w 数组 是否需要变成 前缀和 数组</strong>。</p><h2 id="状态转移-3"><a class="anchor" href="#状态转移-3">#</a> 状态转移</h2><p>在介绍 <code>f 数组</code> 部分，我们已经介绍过<strong>状态的定义</strong>，而之所以要如此定义，是因为在<strong>状态转移</strong>的时候，可以方便的根据上一次的状态把序列分为两部分，一部分是<strong>已知状态</strong>，即，这部分可以<strong>直接通过状态定义求出来</strong>，我们只需要专注在另一部分的逻辑即可。</p><p>而在另一部分的逻辑中，我们通过状态的含义，<strong>来找到需要保持单调的部分</strong>，具体可以参考一下上面的第二个和第三个题目，都有标记出需要进行单调的部分。</p><h1 id="leetcode-1425-带限制的子序列和"><a class="anchor" href="#leetcode-1425-带限制的子序列和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9zdWJtaXNzaW9ucy9kZXRhaWwvMzQwMDYyODQyLw==">LeetCode 1425. 带限制的子序列和</span></h1><blockquote><p>给你一个整数数组  <code>nums</code>  和一个整数  <code>k</code>  ，请你返回 非空 子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数  <code>nums[i]</code>  和  <code>nums[j]</code>  ，它们在原数组中的下标  <code>i</code>  和  <code>j</code>  满足  <code>i &lt; j</code>  且 <code>j - i &lt;= k</code> 。</p><p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p><p></p><p>示例 1：</p><p>输入：nums = [10,2,-10,5,20], k = 2<br>输出：37<br>解释：子序列为 [10, 2, 5, 20] 。</p><p>示例 2：</p><p>输入：nums = [-1,-2,-3], k = 1<br>输出：-1<br>解释：子序列必须是非空的，所以我们选择最大的数字。</p><p>示例 3：</p><p>输入：nums = [10,-2,-10,-5,20], k = 2<br>输出：23<br>解释：子序列为 [10, -2, -5, 20] 。</p><p>提示:</p><p>1 &lt;= k &lt;= nums.length &lt;= 10^5<br>-10^4 &lt;= nums[i] &lt;= 10^4</p></blockquote><h2 id="题目描述-5"><a class="anchor" href="#题目描述-5">#</a> 题目描述</h2><p>给出一个整数数组 <code>nums</code> ，和一个整数 <code>k</code> ，目标是找到<strong>非空 子序列和 的最大值</strong>，</p><p>这里的子序列含义是<strong>保证顺序即可，但是不要求连续</strong>。</p><p>在此基础上，还有一个规则：那就是<strong>相邻两个元素的 下标之差 必须 小于等于 k</strong>。</p><p>把这个规则换一句话说就是：<strong>在 k 个间隔之内必须有一个元素被选择</strong>。如此我们发现本题与前面的题目（烽火传递）竟然非常相似，只不过一个求最小值，本题求的是最大值。</p><p>还有一个很重要的细节，也需要注意到：<strong>本题给出的序列中的元素可能是负数</strong>，这也就是说，虽然本题求的是最大值，但是并不是选择的元素越多越好的。</p><h2 id="套模板"><a class="anchor" href="#套模板">#</a> 套模板</h2><p>我们使用上面总结出来的模板来解决这道题。过程中，我们需要关注这样几个关键点：</p><ol><li><p>首先是判断窗口大小的部分，我们因为是从前往后枚举元素，所以不用动，直接就使用小于号即可。</p></li><li><p>在状态转移的部分，只要使用窗口中的极值（最大值）加上当前元素的权重，也就得到了当前状态。</p><p>这一转移过程与<strong>烽火传递</strong>这道题完全的相同，因此不在展开细节了。但是有一个很关键的点需要注意：<strong>因为本题存在负数的原因，很可能出现 状态转移方程的前半部 (也就是上一状态) 分是负数，但是当前元素是正数，而当前元素与上一状态相加得到的 当前状态 仍然是负数 的这种情况</strong>。</p><p>此时就会错误，因为我们<strong>最后的目标 子序列 是可以任意选择开始的，此时如果我们从当前的正数部分选择无疑是更优的，因为可以使当前状态为正数。</strong></p><p>所以，<strong>我们要判断下上一状态如果是负数，就让他变成 0，以此来让当前元素 作为 当前状态</strong>。</p></li><li><p>在维护队列单调性的部分，因为我们需要维护的是队头元素最大，所以当出现<strong>当前元素 比 队尾元素 更大时，说明队尾元素没用了，把它出队即可</strong>。</p></li><li><p>因为题目中存在负数，所以并不能保证 <code>f[n]</code> 一定是最后的答案，因此，我们遍历整个 <code>f数组</code> 找到最大值。</p></li></ol><h2 id="code-6"><a class="anchor" href="#code-6">#</a> Code</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">constrainedSubsetSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 注意，为了完全的套上模板，我在这里把数组下标移动到从 1 开始。</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token comment">// 关键点 1</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">and</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> k<span class="token punctuation">)</span> hh <span class="token operator">++</span> <span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// 关键点 2</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token comment">// 关键点 3</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">and</span> f<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            q<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">// 关键点 4</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1e9</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">return</span> res<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h1 id="leetcode-1696-跳跃游戏-vi"><a class="anchor" href="#leetcode-1696-跳跃游戏-vi">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUtdmkv">LeetCode 1696. 跳跃游戏 VI</span></h1><blockquote><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code>  和一个整数 <code>k</code>  。</p><p>一开始你在下标  <code>0</code>  处。每一步，你最多可以往前跳  <code>k</code>  步，但你不能跳出数组的边界。也就是说，你可以从下标  <code>i</code>  跳到  <code>[i + 1， min(n - 1, i + k)]</code>  包含 两个端点的任意位置。</p><p>你的目标是到达数组最后一个位置（下标为 <code>n - 1</code>  ），你的 得分 为经过的所有数字之和。</p><p>请你返回你能得到的 最大得分 。</p><p></p><p><strong>示例 1</strong></p><p>输入：nums = [1,-1,-2,4,-7,3], k = 2<br>输出：7<br>解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。<br><strong>示例 2</strong></p><p>输入：nums = [10,-5,-2,4,0,3], k = 3<br>输出：17<br>解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。</p><p><strong>示例 3</strong></p><p>输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2<br>输出：0</p><p><strong>提示</strong></p><p>1 &lt;= nums.length, k &lt;= 105<br>-104 &lt;= nums[i] &lt;= 104</p></blockquote><h2 id="题目描述-6"><a class="anchor" href="#题目描述-6">#</a> 题目描述</h2><p>给出一个序列 <code>nums</code> 和一个正数 <code>k</code> ，从下标 <code>0</code> 开始，向后遍历并选择元素并且尽量让所选元素和最大，注意元素并非全是正数，因此并不是选择越多越好。除此之外，还有选择的规则：每次只能在当前元素的后 k 个元素中做选择。换句话说就是：<strong>k 个间隔之内必须有一个元素被选择</strong>。</p><h2 id="套模板-2"><a class="anchor" href="#套模板-2">#</a> 套模板</h2><p>从题目描述中我们可以发现，本题其实<strong>和上一道题几乎一模一样</strong>，因此，本题权当留给读者当作业（<s>绝对不是我写的太累了</s>），自己去试着从分析到代码，完整的做一遍。</p><p>仍然要提示的是，本题虽然与上题很相似，但是还有一个小的关键点需要注意。即，在上一个题目中，序列是可以随意进行选择的，但是本题<strong>必须从第一个元素就开始选择，且第一个元素是必选的</strong>（可以从示例看出来）。</p><p>因此，我们的应对之法就是<strong>首先把 f [0] 初始化为第一个元素的值，那么剩下的序列就从 1 开始了，再参考上一题就可以了</strong>。</p><h2 id="code-7"><a class="anchor" href="#code-7">#</a> Code</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">maxResult</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 第一个元素默认必须选择 因此后面的序列下标直接从 1 开始</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 所以我们没有像上题一样把 nums 的下标改成 1~n。</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 单调队列优化 与上题完全相同 注意最后一个元素是 n-1。</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">and</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> k<span class="token punctuation">)</span> hh <span class="token operator">++</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">and</span> f<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            q<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>END</strong></p><div class="tags"><a href="/tags/LeetCode/" rel="tag"><i class="ic i-tag"></i> LeetCode</a> <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="tag"><i class="ic i-tag"></i> 前缀和</a> <a href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" rel="tag"><i class="ic i-tag"></i> 单调队列</a> <a href="/tags/%E4%BA%8C%E5%88%86/" rel="tag"><i class="ic i-tag"></i> 二分</a> <a href="/tags/AcWing%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/" rel="tag"><i class="ic i-tag"></i> AcWing算法提高课</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-08-28 23:30:56" itemprop="dateModified" datetime="2022-08-28T23:30:56+08:00">2022-08-28</time> </span><span id="看完必会的单调队列优化DP攻略/" class="item leancloud_visitors" data-flag-title="看完必会的单调队列优化DP攻略" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/wechatpay.png" alt="A Cat Without Sugar 微信支付"><p>微信支付</p></div><div><img data-src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/alipay.png" alt="A Cat Without Sugar 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>A Cat Without Sugar <i class="ic i-at"><em>@</em></i>小猫咪吃python</li><li class="link"><strong>本文链接：</strong> <a href="http://yoursite.com/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP%E6%94%BB%E7%95%A5/" title="看完必会的单调队列优化DP攻略">http://yoursite.com/看完必会的单调队列优化DP攻略/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%9C%AC%E4%B9%A6--%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicit4jrvuj20zk0m8785.jpg" title="推荐一本书《被讨厌的勇气》"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 书籍推荐</span><h3>推荐一本书《被讨厌的勇气》</h3></a></div><div class="item right"><a href="/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E6%90%9C%E7%B4%A2%E4%B9%8B%E8%B6%85%E7%BB%8F%E5%85%B8flood%20fill%E9%97%AE%E9%A2%98%E6%94%BB%E7%95%A5/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevo9j1jj20zk0m8e81.jpg" title="看完必会的搜索之超经典flood fill问题攻略"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 搜索</span><h3>看完必会的搜索之超经典flood fill问题攻略</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">单调队列优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#acwing-135-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">2.</span> <span class="toc-text">AcWing 135. 最大子序和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">题目示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code"><span class="toc-number">2.4.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#acwing-1087-%E4%BF%AE%E5%89%AA%E8%8D%89%E5%9D%AA"><span class="toc-number">3.</span> <span class="toc-text">AcWing 1087. 修剪草坪</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-2"><span class="toc-number">3.2.</span> <span class="toc-text">题目分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">状态定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-number">3.2.2.</span> <span class="toc-text">状态转移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-2"><span class="toc-number">3.3.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#acwing-1089-%E7%83%BD%E7%81%AB%E4%BC%A0%E9%80%92"><span class="toc-number">4.</span> <span class="toc-text">AcWing 1089. 烽火传递</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-3"><span class="toc-number">4.2.</span> <span class="toc-text">题目分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89-2"><span class="toc-number">4.2.1.</span> <span class="toc-text">状态定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB-2"><span class="toc-number">4.2.2.</span> <span class="toc-text">状态转移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-3"><span class="toc-number">4.3.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#acwing-1090-%E7%BB%BF%E8%89%B2%E9%80%9A%E9%81%93"><span class="toc-number">5.</span> <span class="toc-text">AcWing 1090. 绿色通道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">5.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-4"><span class="toc-number">5.2.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-4"><span class="toc-number">5.3.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#code-5"><span class="toc-number">6.1.</span> <span class="toc-text">Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">基本参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB-3"><span class="toc-number">6.3.</span> <span class="toc-text">状态转移</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-1425-%E5%B8%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-number">7.</span> <span class="toc-text">LeetCode 1425. 带限制的子序列和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-number">7.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%97%E6%A8%A1%E6%9D%BF"><span class="toc-number">7.2.</span> <span class="toc-text">套模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-6"><span class="toc-number">7.3.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi"><span class="toc-number">8.</span> <span class="toc-text">LeetCode 1696. 跳跃游戏 VI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-number">8.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%97%E6%A8%A1%E6%9D%BF-2"><span class="toc-number">8.2.</span> <span class="toc-text">套模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-7"><span class="toc-number">8.3.</span> <span class="toc-text">Code</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/LeetCode%20913.%20%E7%8C%AB%E5%92%8C%E8%80%81%E9%BC%A0/" rel="bookmark" title="LeetCode 913. 猫和老鼠">LeetCode 913. 猫和老鼠</a></li><li><a href="/AcWing%20898.%20%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2/" rel="bookmark" title="AcWing 898. 数字三角形">AcWing 898. 数字三角形</a></li><li><a href="/AcWing%20895.%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/" rel="bookmark" title="AcWing 895. 最长上升子序列">AcWing 895. 最长上升子序列</a></li><li><a href="/AcWing%20291.%20%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3/" rel="bookmark" title="AcWing 291. 蒙德里安的梦想">AcWing 291. 蒙德里安的梦想</a></li><li><a href="/AcWing%20338.%20%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/" rel="bookmark" title="AcWing 338. 计数问题">AcWing 338. 计数问题</a></li><li><a href="/LeetCode%20691.%20%E8%B4%B4%E7%BA%B8%E6%8B%BC%E8%AF%8D%EF%BC%88%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%88%86%E6%90%9C%EF%BC%89/" rel="bookmark" title="LeetCode 691. 贴纸拼词">LeetCode 691. 贴纸拼词</a></li><li><a href="/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%9A%84%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96/" rel="bookmark" title="多重背包的终极优化">多重背包的终极优化</a></li><li class="active"><a href="/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP%E6%94%BB%E7%95%A5/" rel="bookmark" title="看完必会的单调队列优化DP攻略">看完必会的单调队列优化DP攻略</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="A Cat Without Sugar" data-src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/avatar.jpg"><p class="name" itemprop="name">A Cat Without Sugar</p><div class="description" itemprop="description">孤独与剑，自由与酒</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">46</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">10</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">59</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%9C%AC%E4%B9%A6--%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E6%90%9C%E7%B4%A2%E4%B9%8B%E8%B6%85%E7%BB%8F%E5%85%B8flood%20fill%E9%97%AE%E9%A2%98%E6%94%BB%E7%95%A5/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/" title="分类于 图论">图论</a></div><span><a href="/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E4%B9%8Bbellman-ford%E6%B1%82%E9%99%90%E5%88%B6%E8%BE%B9%E6%95%B0%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF/" title="图论基础之bellman-ford求限制边数的最短路">图论基础之bellman-ford求限制边数的最短路</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/" title="分类于 图论">图论</a></div><span><a href="/Spfa%E6%B1%82%E8%B4%9F%E7%8E%AF%E7%9A%84%E5%B8%B8%E8%A7%84%E6%80%9D%E8%B7%AF/" title="Spfa求负环的常规思路">Spfa求负环的常规思路</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/" title="分类于 搜索">搜索</a></div><span><a href="/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%94%BB%E7%95%A5/" title="看完必会的回溯算法入门攻略">看完必会的回溯算法入门攻略</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="有趣的数据结构-二叉堆的实现">有趣的数据结构-二叉堆的实现</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/" title="分类于 数学">数学</a></div><span><a href="/%E6%95%B0%E8%AE%BA%E4%B8%AD%E7%9A%84%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/" title="数论中的乘法逆元">数论中的乘法逆元</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/" title="分类于 数学">数学</a></div><span><a href="/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E9%97%AE%E9%A2%98(%E4%B8%80)/" title="有趣的博弈论问题(一)">有趣的博弈论问题(一)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%A5%E9%97%A8%E6%94%BB%E7%95%A5/" title="看完必会的滑动窗口入门攻略">看完必会的滑动窗口入门攻略</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/" title="分类于 图论">图论</a></div><span><a href="/%E7%94%A8%E6%81%8B%E7%88%B1%E5%BE%AA%E7%8E%AF%E7%AE%97%E6%B3%95%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E6%95%B0/" title="用恋爱循环算法来解决二分图的最大匹配数">用恋爱循环算法来解决二分图的最大匹配数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="分类于 动态规划">动态规划</a></div><span><a href="/LeetCode%20691.%20%E8%B4%B4%E7%BA%B8%E6%8B%BC%E8%AF%8D%EF%BC%88%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%88%86%E6%90%9C%EF%BC%89/" title="LeetCode 691. 贴纸拼词">LeetCode 691. 贴纸拼词</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" title="分类于 书籍推荐">书籍推荐</a></div><span><a href="/%E8%B6%85%E7%BA%A7%E5%8A%A0%E5%80%8D%E6%8E%A8%E8%8D%90%E4%B8%80%E6%9C%AC%E8%B6%A3%E5%91%B3%E7%A7%91%E6%99%AE%E7%B1%BB%E7%9A%84%E4%B9%A6--%E3%80%8A%E7%8C%AB%EF%BC%8C%E7%88%B1%E5%9B%A0%E6%96%AF%E5%9D%A6%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%8B/" title="推荐一本书《猫，爱因斯坦和密码学》">推荐一本书《猫，爱因斯坦和密码学》</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">A Cat Without Sugar @ The Cat to eat Python</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">249k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:47</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"看完必会的单调队列优化DP攻略/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{appId:"TsHNizG5g9yTU8EUAa1EIkH5-gzGzoHsz",appKey:"KSmBGGzCyE4Pnop6qF4aD39B",placeholder:"ヽ(○´∀`)ﾉ♪",pageSize:10,lang:"zh-CN",tagMember:{master:["deea5a8d259d17182a53be1772e4c182"],friend:["deea5a8d259d17182a53be1772e4c182"]}},copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/js/app.js?v=0.2.5"></script></body></html>