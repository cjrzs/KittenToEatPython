<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="小猫咪吃python" href="http://yoursite.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="小猫咪吃python" href="http://yoursite.com/atom.xml"><link rel="alternate" type="application/json" title="小猫咪吃python" href="http://yoursite.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/css/app.css?v=0.2.5"><meta name="keywords" content="Asyncio专题,生成器,源码分析"><link rel="canonical" href="http://yoursite.com/python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8(yield%E4%B8%8Eyield%20from)/"><title>python中的生成器(yield与yield from) - python | The Cat to eat Python = 小猫咪吃python = 唤起一天明月 照我满怀冰雪 浩荡百川流 鲸饮未吞海 剑气已横秋</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">python中的生成器(yield与yield from)</h1><div class="meta"><span class="item" title="创建时间：2021-12-31 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-12-31T00:00:00+08:00">2021-12-31</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>19k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>17 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">The Cat to eat Python</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhpw3lwj20zk0m8gvw.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipex2cdtbj20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeu7txpzj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclj61ylzj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/python/" itemprop="item" rel="index" title="分类于 python"><span itemprop="name">python</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://yoursite.com/python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8(yield%E4%B8%8Eyield%20from)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/avatar.jpg"><meta itemprop="name" content="A Cat Without Sugar"><meta itemprop="description" content="唤起一天明月 照我满怀冰雪 浩荡百川流 鲸饮未吞海 剑气已横秋, 孤独与剑，自由与酒"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小猫咪吃python"></span><div class="body md" itemprop="articleBody"><h1 id="导读"><a class="anchor" href="#导读">#</a> 导读</h1><p>本文作为<strong> asyncio 专题</strong>系列的引导文章，主要定位是引导读者熟悉 <code>asyncio</code> 相关的前置知识<strong>生成器</strong>。文章字数较多（不算代码字数 1w+，算上代码 1.8w+），全部阅读完大概需要 43 分钟。</p><p>笔者深知字数较多的文章会让人丧失继续阅读的兴趣，并且读者水平不同，可能有人早已掌握文章内容，因此我在下面简单描述了本文四个小节的重点内容，<strong>您可以根据自身情况选择阅读</strong>。</p><h2 id="初始阶段迭代器"><a class="anchor" href="#初始阶段迭代器">#</a> 初始阶段，迭代器</h2><ol><li>来自 PEP234。本节重点描述了迭代器的功能与优势。</li><li>迭代器的出现增强了 python 中的迭代能力，并且给 dict 和 file 类型提供更方便、快速的迭代方式。</li><li>其主要依赖的魔术方法有两个<strong> iter</strong> 和<strong> next</strong>。</li><li>存在的问题是<strong>当调用者想要维护迭代的中间值的时候，会比较困难，通常需要用回调函数等不直观的方式</strong>。</li></ol><h2 id="第二阶段生成器"><a class="anchor" href="#第二阶段生成器">#</a> 第二阶段，生成器</h2><ol><li>来自 PEP255。生成器完全继承迭代器协议。生成器是非常重要的一个特性，后续的协程也是基于它，因此本节用了大部分的篇幅<strong>分析生成器源码</strong>，力求从<strong>根本上理解生成器的运行原理</strong>。</li><li>生成器中，解决了<strong>迭代器</strong>中存在的问题，它允许生成器函数从停止的地方继续执行，并且提供了新函数让调用者与生成器函数交互。</li><li>新增了一个表达式 <code>yield</code> ，以及新增了 <code>send</code> 函数。</li><li>该阶段仍然存在一些问题，比如<strong>生成器之间的调用（代码解耦）</strong>、<strong>获取最后 return 的返回值</strong>、<strong>生成器与调用者之间的异常处理</strong>等。</li></ol><h2 id="第三阶段委托生成器"><a class="anchor" href="#第三阶段委托生成器">#</a> 第三阶段，委托生成器</h2><ol><li>来自 PEP380。委托生成器的作用是增强生成器，它<strong>解决了上面生成器有关的问题</strong>。坏处是<strong>委托生成器异常的难理解</strong> (PEP380 的作者也同意这个观点)。但是官方给了一段伪代码，这段伪代码直观的阐明了委托生成器的工作原理，因此本节的重点在于<strong>结合实际例子代入到伪代码中，详细描述了委托生成器的执行逻辑</strong>。</li><li>委托生成器会作为类似<strong>中间人</strong>的角色，将左面的表达式变成迭代器，不断的从调用者获取值传给迭代器处理，又把迭代器的处理结果传给调用者，在这中间过程中又做了完整的异常处理。</li><li>新增一个表达式 <code>yield from</code> 。</li><li>该阶段在 PEP342 中又增加了一些方法 close，throw 等，为用生成器实现协程铺平道路，但是依旧不可否认的是<strong>生成器虽然可以实现协程，但它并不是真正的协程，使用的关键字与其他语言也不同，因此并不方便掌握</strong>。</li></ol><h2 id="现阶段协程-asyncawait"><a class="anchor" href="#现阶段协程-asyncawait">#</a> 现阶段，协程 async/await</h2><ol><li>在 PEP492 中，终于提出了真正的协程。本节的重点是用一个简单的小例子，表明了生成器和 <code>await</code> 在使用上的区别。</li><li>协程和生成器，最明显的不同就是 <code>await</code> 必须配合可调用对象使用，表现出来的作用与 <code>yield from</code> 的均相同。</li><li>在该阶段引入了很多新特性。包括一个新的概念可调用对象 <code>awaitable</code> ，一个重要的魔术方法 <code>__await__</code> 实现自定义协程，两个重要的魔术方法 <code>__aenter__</code> 和 <code>__aexit__</code> 用来实现自定义异步上下文管理器，两个表达协程的关键字 <code>async/await</code> 以及其他众多的新增概念（本系列文章后面均会提及）。</li><li>本文定位在于熟练掌握协程的前置知识，因此对于协程本身相关并没有太多的内容。</li></ol><h1 id="幼年期的迭代器-iterator"><a class="anchor" href="#幼年期的迭代器-iterator">#</a> 幼年期的迭代器 iterator</h1><p>关键字 <code>yield</code> 首次被引入到 python 中是在 PEP255，但是它依赖的另外一个特性尤在它之前出现，那就是迭代器。</p><p>PEP234 中首次引入了迭代器这一概念。并且引入了一个内置函数 <code>iter</code> 用来创建迭代器。 <code>iter</code> 函数有两种用法：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 1、iter (iterable) 以一个可迭代对象作为参数</span></pre></td></tr><tr><td data-num="2"></td><td><pre>iter_obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment"># list 可能是我们最熟悉的可迭代对象</span></pre></td></tr><tr><td data-num="3"></td><td><pre>list_iter <span class="token operator">=</span> <span class="token builtin">iter</span><span class="token punctuation">(</span>iter_obj<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>list_iter<span class="token punctuation">)</span>  <span class="token comment"># &lt;list_iterator object ...></span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 2、iter (callable, sentinel) 以一个可调用对象做参数 并设置哨兵</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">def</span> <span class="token function">call_obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 定义一个函数作为可调用对象</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre>call_iter <span class="token operator">=</span> <span class="token builtin">iter</span><span class="token punctuation">(</span>call_obj<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>call_iter<span class="token punctuation">)</span>  <span class="token comment"># &lt;callable_iterator object ...></span></pre></td></tr></table></figure><p>而所有的迭代器都有一个<strong>魔术方法 next</strong>，以控制当我们使用内置函数 <code>next</code> 来调用它们进行迭代时候的行为。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hasattr</span><span class="token punctuation">(</span>list_iter <span class="token punctuation">,</span> <span class="token string">'__next__'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># True</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hasattr</span><span class="token punctuation">(</span>call_iter <span class="token punctuation">,</span> <span class="token string">'__next__'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># True</span></pre></td></tr></table></figure><p>对于任意迭代器，我们都可以使用两种方式对他们进行迭代，一种是 <code>for</code> 循环的方式，另一种就是上面所说的用内置函数 <code>next</code> 。</p><p>并且这两种方式的迭代都做同一件事：从迭代器中取出元素。在下面的例子中我们先用 <code>next</code> 取出一个元素，之后再用 <code>for</code> 循环取出剩下的两个元素。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'next函数迭代：</span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token builtin">next</span><span class="token punctuation">(</span>list_iter<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>  <span class="token comment"># next 函数迭代：1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> item <span class="token keyword">in</span> list_iter<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'for循环迭代：</span><span class="token interpolation"><span class="token punctuation">&#123;</span>item<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>  <span class="token comment"># for 循环迭代：2  for 循环迭代：3</span></pre></td></tr></table></figure><p>它们的区别是：对于 <code>for</code> 循环来说，迭代器中如果没有元素会直接终止循环；而 <code>next</code> 函数如果没有取到元素，则会报指定异常 <code>StopIteration</code> 。这样做的一个好处是迭代器的迭代过程不会被任何其他异常所阻断。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 在上面的例子中我们已经取出了 list_iter 的所有元素</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token builtin">next</span><span class="token punctuation">(</span>list_iter<span class="token punctuation">)</span>  <span class="token comment"># StopIteration</span></pre></td></tr></table></figure><p>除了这些默认行为之外。在迭代器特性中，python 还为我们增强了 <code>dict</code> 和 <code>file</code> 两种基本类型的迭代。我们以字典为例。</p><p><strong>判断某个 key 是否在字典中存在</strong>。如果没有迭代器，我们应写为：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token builtin">dict</span><span class="token punctuation">.</span>has_key<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><p>但是有了迭代器，我们可以用更直观的方式表达这一语意：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># if k in dict: ...</span></pre></td></tr><tr><td data-num="2"></td><td><pre>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token string">'Jinx'</span><span class="token punctuation">:</span> <span class="token string">'爆爆'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token string">'Vi'</span><span class="token punctuation">:</span> <span class="token string">'蔚'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token string">'Caitlyn'</span><span class="token punctuation">:</span> <span class="token string">'小蛋糕'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token string">'Jayce'</span><span class="token punctuation">:</span> <span class="token string">'议员'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token string">'Viktor'</span><span class="token punctuation">:</span> <span class="token string">'光荣进化'</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">if</span> <span class="token string">'Jinx'</span> <span class="token keyword">in</span> data<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token string">'Jinx'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 爆爆</span></pre></td></tr></table></figure><p><strong>对一个 dict 进行迭代访问</strong>。该场景下，我们想要像访问其他可迭代序列一样，访问到字典的所有元素，在这样的迭代过程中，不应该修改 <code>dict</code> ，并且应该允许为现有的 key 设置 value，这意味着我们可以直接把字典的遍历设置成对字典 key 的遍历。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> k <span class="token keyword">in</span> data<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>  <span class="token comment"># Jinx Vi Caitlyn Jayce Viktor</span></pre></td></tr></table></figure><p>当然，还有另外一种方式也可以做到：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> k <span class="token keyword">in</span> data<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>  <span class="token comment"># Jinx Vi Caitlyn Jayce Viktor</span></pre></td></tr></table></figure><p>比较两种方法，显然是第一种更快，因为它少了一步访问 <code>dict.keys</code> 函数的过程，而是直接遍历了 <code>dict</code> 的 key。</p><p>除了对 <code>dict</code> 和 <code>file</code> 的增强以外，迭代器更加重要的一个作用是控制自定义类的迭代行为。也就是说迭代器的强大之处在于它向后兼容所有模仿序列和映射的自定义类和扩展对象。</p><p>下面的例子，我们自定义一个类，来更改基本类型 <code>dict</code> 的默认迭代行为：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyDict</span><span class="token punctuation">(</span><span class="token builtin">dict</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        self<span class="token punctuation">.</span>idx <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 维护当前迭代元素</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> self</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            item <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>idx<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">except</span> IndexError<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">raise</span> StopIteration  <span class="token comment"># 必须使用该异常</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        self<span class="token punctuation">.</span>idx <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> item</pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>iter2 <span class="token operator">=</span> <span class="token builtin">iter</span><span class="token punctuation">(</span>MyDict<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>iter2<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 爆爆</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>iter2<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 蔚</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">for</span> item <span class="token keyword">in</span> iter2<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>  <span class="token comment"># 小蛋糕 议员 光荣进化</span></pre></td></tr></table></figure><p>在这个例子的结果中，我们把 <code>dict</code> 默认迭代 key 的行为变成了默认迭代 value，并且顺利的使用内置函数 <code>next</code> 和 <code>for</code> 循环遍历了 <code>dict</code> 中的所有 value。</p><p>可以明显的看到除了 <code>init</code> 外，这个自定义类 MyDict 还<strong>同时</strong>实现了两个<strong>魔术方法 <code>iter</code> 和 <code>next</code> </strong>。这两个魔术方法在 PEP234 中均有提到，其中<strong>魔术方法 iter</strong> 是迭代器的核心函数，它的返回值必须是一个可迭代对象。它的含义是告诉解释器该自定义类是可迭代的，以及要迭代的对象是谁。而<strong>魔术方法 next</strong> 的功能比较明显，即控制 <code>MyDict</code> 的默认迭代行为，并且把自定义类变成迭代器类型。</p><p>迭代器的作用：</p><p>1、使数据的迭代变得可以扩展；增强迭代性能；<br>2、提供更强性能的 dict 迭代；<br>3、为迭代提供一个接口，而不是让这一过程看起来像是随机访问；<br>4、兼容性极强，可迭代序列、可调用对象、自定义类、扩展对象等都可以定义迭代的行为；<br>5、使迭代的代码可以更加简洁；</p><h1 id="迭代器进化-生成器"><a class="anchor" href="#迭代器进化-生成器">#</a> 迭代器进化 --&gt; 生成器</h1><p>在 PEP255 中引入了新的概念，也就是本文的主角：生成器以及它的衍生品 yield。</p><h2 id="问题"><a class="anchor" href="#问题">#</a> 问题</h2><p><strong>当生产者函数想要在生成的值之间维护状态时</strong>。通常要用麻烦的方式，比如用回调函数等，但遗憾的是，即便可以实现，代码也不好理解。</p><p>幸好，我们有了迭代器，无论何时，只要生产者函数需要下一个值就可以简单的通过内置函数 next 来获取，这样使代码看起来简洁、优雅、易读，并且只需要把当前正在使用的值放到内存中，也可以简化内存的占用，还有一个好处是随时可以结束对生产者函数产出值的处理，即不在调用 next 函数生产新的值。</p><p>但是使用迭代器，会引发另一个问题：<strong>必须要手动维护当前函数的执行状态</strong>。然而这是一笔非常大的开销。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyDict</span><span class="token punctuation">(</span><span class="token builtin">dict</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        self<span class="token punctuation">.</span>idx <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 维护当前迭代元素</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        self<span class="token punctuation">.</span>idx <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr></table></figure><p>以上节迭代器中的 MyDict 为例，我想要让 MyDict 每次都向迭代字典的下一个值，就要用一个额外的下标参数 idx 去控制，这样才能在第二次调用 next 的时候生产出第二个 value 值。显然如果在更复杂的场景中，<strong>“维护当前状态” 这件事会花费更大的开销</strong>。</p><h2 id="yield"><a class="anchor" href="#yield">#</a> yield</h2><p>为了解决这件事，生成器应运而生。生成器可以保存函数运行的局部状态，以便函数在停止的地方再次恢复。</p><h3 id="有两种方式定义生成器"><a class="anchor" href="#有两种方式定义生成器">#</a> 有两种方式定义生成器</h3><p>1、类似列表推导式，但是生成器使用小括号。创建一个过滤列表数字，只保留偶数的生成器。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>l <span class="token operator">=</span> <span class="token punctuation">[</span>item <span class="token keyword">for</span> item <span class="token keyword">in</span> data <span class="token keyword">if</span> item <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span>  <span class="token comment"># [2, 4]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>gen1 <span class="token operator">=</span> <span class="token punctuation">(</span>item <span class="token keyword">for</span> item <span class="token keyword">in</span> data <span class="token keyword">if</span> item <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>g1<span class="token punctuation">)</span>  <span class="token comment"># &lt;generator object gen...></span></pre></td></tr></table></figure><p>2、另外一种方式就是在 PEP255 中新引入的一个关键字 <code>yield</code> 。<strong>即该 yield 所在的函数，整体就是一个生成器</strong>。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">gen</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> item <span class="token keyword">in</span> data<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> item <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">yield</span> item</pre></td></tr><tr><td data-num="5"></td><td><pre>gen2 <span class="token operator">=</span> gen<span class="token punctuation">(</span>data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>gen2<span class="token punctuation">)</span>  <span class="token comment"># &lt;generator object gen...></span></pre></td></tr></table></figure><h3 id="生成器完全支持迭代器协议"><a class="anchor" href="#生成器完全支持迭代器协议">#</a> 生成器完全支持迭代器协议</h3><p>为了保持迭代器相同的特性，生成器完全支持了迭代器的协议（即实现了 <code>iter</code> 和 <code>next</code> 两个魔术方法），因此生成器可以使用迭代器的方式调用。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>gen2<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 2</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> item <span class="token keyword">in</span> gen2<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>  <span class="token comment"># 4</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>gen2<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># StopIteration</span></pre></td></tr></table></figure><h4 id="生成器会记录函数当前执行位置下次执行从该位置开始"><a class="anchor" href="#生成器会记录函数当前执行位置下次执行从该位置开始">#</a> 生成器会记录函数当前执行位置，下次执行从该位置开始</h4><p>用一个简单例子来说明该特性。（该例子没有任何的实际作用，仅仅是为了阐明生成器在代码中的执行流程。）</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">simple_coro2</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 代码 1</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'start a = </span><span class="token interpolation"><span class="token punctuation">&#123;</span>a<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>  <span class="token comment"># 代码 2</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    b <span class="token operator">=</span> <span class="token keyword">yield</span> a  <span class="token comment"># 代码 3</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'receive b = </span><span class="token interpolation"><span class="token punctuation">&#123;</span>b<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>  <span class="token comment"># 代码 4</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    c <span class="token operator">=</span> <span class="token keyword">yield</span> a <span class="token operator">+</span> b  <span class="token comment"># 代码 5</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'receive c = </span><span class="token interpolation"><span class="token punctuation">&#123;</span>c<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>  <span class="token comment"># 代码 6</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    </pre></td></tr><tr><td data-num="8"></td><td><pre>coro2 <span class="token operator">=</span> simple_coro2<span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span>  <span class="token comment"># 执行该函数</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>coro2<span class="token punctuation">)</span>  <span class="token comment"># &lt;generator object simple_coro2...></span></pre></td></tr></table></figure><p>现在得到了一个生成器，可以看到如果是生成器函数，当我们直接执行它的时候，仅仅是得到一个生成器对象。如果想操作该生成器函数，必须使用内置函数 <code>next()</code> 和 <code>generator.send()</code> 。</p><p>生成器函数有两个功能：<strong>产出</strong>和<strong>让步</strong>。简单讲，就是将 <code>yield</code> 右边的值传递给调用者，并且将执行权交给调用者。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>val <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>coro2<span class="token punctuation">)</span>  <span class="token comment"># 打印 start a = 66</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment"># 66 将 yield 右面的 &#123;a&#125; 传给调用者</span></pre></td></tr></table></figure><p>此时为了使生成器函数向下执行，可以继续使用 <code>next()</code> 。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token builtin">next</span><span class="token punctuation">(</span>coro2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># TypeError: 'int' and 'NoneType'</span></pre></td></tr></table></figure><p>继续 <code>next()</code> 发现，报错 <code>TypeErroe</code> 。这是因为在代码 3 处参数 b 在 <code>yield</code> 的左面，表示接收了一个 <code>yield</code> (调用者) 提供的值，是需要调用方使用 <code>send()</code> 函数提供的，而不是 <code>next()</code> 。如果没有使用 <code>send()</code> 函数提供数据，强行使用 <code>next()</code> 让生成器继续向下，则会产生一个默认值 <code>None</code> 做为 b 的值。所以再执行到代码 5 的时候 a 是 <code>int</code> 类型、b 是 <code>None</code> ，因此报错。正确的做法是使用 <code>send()</code> 方法为生成器函数提供值。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>val2 <span class="token operator">=</span> coro2<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>  <span class="token comment"># receive b = 15</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>val2<span class="token punctuation">)</span>  <span class="token comment"># 81</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>val3 <span class="token operator">=</span> coro2<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment"># receive c = 10</span></pre></td></tr></table></figure><p>可以看到，在调用者调用 <code>send()</code> 之后，不仅将 <code>send()</code> 提供的值传递给生成器函数，还能让生成器函数继续向下执行，而且最重要的一点<strong>生成器函数记住了它自己执行到了 <code>yield</code> 处</strong>，下次执行就从 <code>yield</code> （代码 3）的左面继续执行。</p><p>为了更加熟悉生成器的运行，引用《流畅的 python》中的例子。该例子中我们要完成<strong>定义一个生成器，求平均值并且返回结果。</strong></p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># count 是参与计算的值的个数，average 是平均值</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Result <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Result'</span><span class="token punctuation">,</span> <span class="token string">'count average'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">def</span> <span class="token function">averager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    total <span class="token operator">=</span> <span class="token number">0.0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    cnt <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    average <span class="token operator">=</span> <span class="token boolean">None</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>  <span class="token comment"># 死循环 会一直接值 并计算</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        term <span class="token operator">=</span> <span class="token keyword">yield</span> average  <span class="token comment"># 代码 1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token keyword">not</span> term<span class="token punctuation">:</span>  <span class="token comment"># 代码 2</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">break</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        total <span class="token operator">+=</span> term</pre></td></tr><tr><td data-num="12"></td><td><pre>        cnt <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        average <span class="token operator">=</span> total <span class="token operator">/</span> cnt  <span class="token comment"># 代码 3</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> Result<span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> average<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>coro_avg <span class="token operator">=</span> averager<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 实例化生成器</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token builtin">next</span><span class="token punctuation">(</span>coro_avg<span class="token punctuation">)</span>  <span class="token comment"># 预先激活生成器 执行到代码 1</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment"># 调用者发送一个值 10 执行到代码 3 计算出平均值</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment"># 再执行到带代码 1 通过 yield 将 average 给调用者</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>coro_avg<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 10</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>coro_avg<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 15</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment"># 当调用者传给生成器一个 None 的时候，代码 2 中的 break 会被执行，推出死循环</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>coro_avg<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">except</span> StopIteration <span class="token keyword">as</span> e<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token comment"># 从异常中获取 return 的返回值。</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>value<span class="token punctuation">)</span>  <span class="token comment"># Result(count=2, average=15.0)</span></pre></td></tr></table></figure><ol><li>代码 1：产出 <code>yield</code> 值给调用者，并且让出执行权给调用者，并且接受调用者回传的值。</li><li>代码 2：调用者传入 <code>None</code> 的时候作为循环结束信号，生成器抛出异常 <code>StopIteration</code> ，退出循环，走到 return 语句。</li><li>代码 3：主要逻辑，计算平均值。</li></ol><h2 id="源码分析"><a class="anchor" href="#源码分析">#</a> 源码分析</h2><h3 id="字节码"><a class="anchor" href="#字节码">#</a> 字节码</h3><p><strong>想要知道生成器是如何工作的</strong>，我们可以去字节码里寻找答案。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> dis <span class="token keyword">import</span> dis</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>dis<span class="token punctuation">(</span>simple_coro2<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre>             <span class="token number">10</span> CALL_FUNCTION            <span class="token number">1</span></pre></td></tr><tr><td data-num="6"></td><td><pre>             <span class="token number">12</span> POP_TOP</pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token number">6</span>          <span class="token number">14</span> LOAD_FAST                <span class="token number">0</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>             <span class="token number">16</span> YIELD_VALUE</pre></td></tr><tr><td data-num="9"></td><td><pre>             <span class="token number">18</span> STORE_FAST               <span class="token number">1</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><p>我们把这个字节码连起来读一下就是<strong>调用一个函数，从栈顶弹出执行元素，加载 yield 后面的常量</strong>， <code>yield</code> 这个关键字对应的字节码<strong> YIELD_VALUE</strong>。</p><p>在执行 <code>CALL_FUNCTION</code> 字节码的时候，就会判断出该函数是生成器函数，从而最后返回一个生成器，而不是直接执行。</p><h3 id="虚拟机栈帧"><a class="anchor" href="#虚拟机栈帧">#</a> 虚拟机栈帧</h3><p>在<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvcDlOaGI0ZGRKaTVjbEprY0JETGZSUQ==">以前的文章</span>中，已经提到了 python 的字节码是由虚拟机去执行的，并且 python 代码被编译后会产生 <code>PyCodeObject</code> 对象。但是想要明白生成器的工作过程，还要简单了解一下虚拟机到底是如何执行这些字节码的。</p><p>首先虚拟机会为要执行的代码准备好<strong>执行环境</strong>，也就是保存了执行上下文的栈帧对象。为了与后文的内部栈帧区分，我们叫它<strong>外部栈帧</strong>，它的头文件在 <code>Include/cpython/frameobject.h</code> 。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">_frame</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    PyObject_HEAD</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">_frame</span> <span class="token operator">*</span>f_back<span class="token punctuation">;</span>      <span class="token comment">/* 前一个_frame，也就是该栈帧的调用者 */</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">_interpreter_frame</span> <span class="token operator">*</span>f_frame<span class="token punctuation">;</span> <span class="token comment">/* 指向实际栈帧数据的指针 */</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    PyObject <span class="token operator">*</span>f_trace<span class="token punctuation">;</span>          <span class="token comment">/* Trace function */</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在头文件中，我们找到了一个重要的结构体，<strong>内部栈帧 <code>_interpreter_frame</code> </strong>，该结构体中承载着虚拟机执行环境的真正数据，它的相关头文件在 <code>Include/internal/pycore_frame.h</code> 。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_interpreter_frame</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    PyFunctionObject <span class="token operator">*</span>f_func<span class="token punctuation">;</span> <span class="token comment">/* 函数对象引用 */</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    PyObject <span class="token operator">*</span>f_globals<span class="token punctuation">;</span> <span class="token comment">/* 全局名字空间 */</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    PyObject <span class="token operator">*</span>f_builtins<span class="token punctuation">;</span> <span class="token comment">/* 内建名字空间 */</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    PyObject <span class="token operator">*</span>f_locals<span class="token punctuation">;</span> <span class="token comment">/* 局部名字空间 *、</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    PyCodeObject *f_code; /* 代码对象引用 */</pre></td></tr><tr><td data-num="7"></td><td><pre>    PyFrameObject <span class="token operator">*</span>frame_obj<span class="token punctuation">;</span> <span class="token comment">/* 栈帧对象 */</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    PyObject <span class="token operator">*</span>generator<span class="token punctuation">;</span> <span class="token comment">/* 生成器引用 */</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">_interpreter_frame</span> <span class="token operator">*</span>previous<span class="token punctuation">;</span>  <span class="token comment">/* 前一个内部栈帧 */</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">int</span> f_lasti<span class="token punctuation">;</span>       <span class="token comment">/* 最后执行的字节码 */</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">int</span> stacktop<span class="token punctuation">;</span>     <span class="token comment">/* Offset of TOS from localsplus  */</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    PyFrameState f_state<span class="token punctuation">;</span>  <span class="token comment">/* 栈帧状态 */</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span> InterpreterFrame<span class="token punctuation">;</span></pre></td></tr></table></figure><p>该结构体里面有三个最关键的属性：</p><ol><li>f_code：该属性是最核心的当前正在执行的代码对象，字节码就在其中。</li><li>f_lasti：该属性也是核心属性，它记录了上一条执行的字节码序号，默认是 - 1，表示没开始执行。这样就能知道下一条将要执行的字节码是什么。</li><li>previous：指向上一个栈帧对象，这样每个栈帧就能串联起来。</li></ol><p>函数调用的时候，准备执行环境，先创建外层栈帧对象，这样当<strong>调用者调用函数时候</strong>创建会内部栈帧，随着调用函数调用的增长，外部栈帧的 <code>back</code> 和内部栈帧的 <code>previous</code> 会各自保存上一个栈帧，这样就行成了一条调用链，函数执行完毕后，根据这两个属性找到它们的调用者，将结果返回给调用者，这样就行成了代码的执行过程。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> a <span class="token operator">+</span> b</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>当前栈帧是函数 <code>add</code> ，它的 <code>back</code> 属性指向了 <code>print</code> ，所以当它执行出结果后，会寻着 <code>back</code> 返回给 <code>print</code> 。</p><h3 id="生成器源码"><a class="anchor" href="#生成器源码">#</a> 生成器源码</h3><h4 id="ncludecpythongenobjecth"><a class="anchor" href="#ncludecpythongenobjecth">#</a> nclude/cpython/genobject.h</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_PyGenObject_HEAD</span><span class="token expression"><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>    PyObject_HEAD</pre></td></tr><tr><td data-num="3"></td><td><pre>    PyCodeObject <span class="token operator">*</span>prefix##_code<span class="token punctuation">;</span>  <span class="token comment">// 代码对象</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    PyObject <span class="token operator">*</span>prefix##_qualname<span class="token punctuation">;</span>  <span class="token comment">// 生成器名称</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    _PyErr_StackItem prefix##_exc_state<span class="token punctuation">;</span>  <span class="token comment">// 执行状态</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><h4 id="bjectsgenobjectc"><a class="anchor" href="#bjectsgenobjectc">#</a> bjects/genobject.c</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 创建生成器</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">static</span> PyObject <span class="token operator">*</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">gen_new_with_qualname</span><span class="token punctuation">(</span>PyTypeObject <span class="token operator">*</span>type<span class="token punctuation">,</span> PyFrameObject <span class="token operator">*</span>f<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                      PyObject <span class="token operator">*</span>name<span class="token punctuation">,</span> PyObject <span class="token operator">*</span>qualname<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    PyCodeObject <span class="token operator">*</span>code <span class="token operator">=</span> f<span class="token operator">-></span>f_frame<span class="token operator">-></span>f_code<span class="token punctuation">;</span>  <span class="token comment">// 从栈帧获取代码段</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    PyGenObject <span class="token operator">*</span>gen <span class="token operator">=</span> <span class="token function">PyObject_GC_NewVar</span><span class="token punctuation">(</span>PyGenObject<span class="token punctuation">,</span> type<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建生成器对象</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>gen <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">Py_DECREF</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    gen<span class="token operator">-></span>gi_frame_valid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    f<span class="token operator">-></span>f_owns_frame <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    f<span class="token operator">-></span>f_frame <span class="token operator">=</span> frame<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    frame<span class="token operator">-></span>generator <span class="token operator">=</span> <span class="token punctuation">(</span>PyObject <span class="token operator">*</span><span class="token punctuation">)</span> gen<span class="token punctuation">;</span>  <span class="token comment">// 记录当前生成器</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    gen<span class="token operator">-></span>gi_code <span class="token operator">=</span> <span class="token function">PyFrame_GetCode</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取代码块</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">_PyObject_GC_TRACK</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 跟踪 GC</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span>PyObject <span class="token operator">*</span><span class="token punctuation">)</span>gen<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>调用 <code>next</code> 函数时候，向下执行生成器函数。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> PyObject <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">gen_iternext</span><span class="token punctuation">(</span>PyGenObject <span class="token operator">*</span>gen<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    PyObject <span class="token operator">*</span>result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">gen_send_ex2</span><span class="token punctuation">(</span>gen<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>result<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> PYGEN_RETURN<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>调用 <code>send</code> 方法给生成器函数传递数据，同时向下执行生成器函数。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> PyObject <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">gen_send</span><span class="token punctuation">(</span>PyGenObject <span class="token operator">*</span>gen<span class="token punctuation">,</span> PyObject <span class="token operator">*</span>arg<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">gen_send_ex</span><span class="token punctuation">(</span>gen<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">static</span> PyObject <span class="token operator">*</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">gen_send_ex</span><span class="token punctuation">(</span>PyGenObject <span class="token operator">*</span>gen<span class="token punctuation">,</span> PyObject <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token keyword">int</span> exc<span class="token punctuation">,</span> <span class="token keyword">int</span> closing<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    PyObject <span class="token operator">*</span>result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">gen_send_ex2</span><span class="token punctuation">(</span>gen<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>result<span class="token punctuation">,</span> exc<span class="token punctuation">,</span> closing<span class="token punctuation">)</span> <span class="token operator">==</span> PYGEN_RETURN<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在生成器函数向下执行的时候，无论是 <code>next</code> 还是 <code>send</code> 都调用了 <code>gen_send_ex2()</code> 这个函数，只不过在 <code>send</code> 的时候传递了参数（ <code>gen_send_ex2</code> 的第二个参数）。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> PySendResult</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">gen_send_ex2</span><span class="token punctuation">(</span>PyGenObject <span class="token operator">*</span>gen<span class="token punctuation">,</span> PyObject <span class="token operator">*</span>arg<span class="token punctuation">,</span> PyObject <span class="token operator">*</span><span class="token operator">*</span>presult<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>             <span class="token keyword">int</span> exc<span class="token punctuation">,</span> <span class="token keyword">int</span> closing<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    PyThreadState <span class="token operator">*</span>tstate <span class="token operator">=</span> <span class="token function">_PyThreadState_GET</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    InterpreterFrame <span class="token operator">*</span>frame <span class="token operator">=</span> <span class="token punctuation">(</span>InterpreterFrame <span class="token operator">*</span><span class="token punctuation">)</span>gen<span class="token operator">-></span>gi_iframe<span class="token punctuation">;</span>  <span class="token comment">// 内部栈帧，它一直被复用。</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    PyObject <span class="token operator">*</span>result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token operator">*</span>presult <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">//f_lasti &lt; 0 代表第一次调用生成器。此时，如果传递了参数，并且参数不是 None 将引发异常。</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    也就是说第一次调用生成器如果用的是<span class="token function">send</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>，并且arg不是None，将引发该异常。</pre></td></tr><tr><td data-num="13"></td><td><pre>    因此实际使用中，我们会让所有生成器函数生成后自动调用一次<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，一般称为预激生成器。</pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>frame<span class="token operator">-></span>f_lasti <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arg <span class="token operator">&amp;&amp;</span> arg <span class="token operator">!=</span> Py_None<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"can't send non-None value to a "</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                            <span class="token string">"just-started generator"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> PYGEN_ERROR<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 判断生成器是否已经执行。</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// 生成器执行完成的异常判断</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token comment">// 推送 arg 的值到执行帧栈上，这个值由 send 函数发送。</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    result <span class="token operator">=</span> arg <span class="token operator">?</span> arg <span class="token operator">:</span> Py_None<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token function">Py_INCREF</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token function">_PyFrame_StackPush</span><span class="token punctuation">(</span>frame<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token comment">// 从此处开始往后的是核心代码</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token comment">// 把当前的的执行帧栈变成前一个（可以类比链表指针）</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token comment">// （还记得内部栈帧中 previous 属性的作用吗？）</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    frame<span class="token operator">-></span>previous <span class="token operator">=</span> tstate<span class="token operator">-></span>cframe<span class="token operator">-></span>current_frame<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token comment">// 记录当前执行状态 也就是保存当前执行到了哪里  previous_item 保存了当前执行信息</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    gen<span class="token operator">-></span>gi_exc_state<span class="token punctuation">.</span>previous_item <span class="token operator">=</span> tstate<span class="token operator">-></span>exc_info<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token comment">//exc_info 记录当前执行状态</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    tstate<span class="token operator">-></span>exc_info <span class="token operator">=</span> <span class="token operator">&amp;</span>gen<span class="token operator">-></span>gi_exc_state<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token comment">// 执行字节码</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    result <span class="token operator">=</span> <span class="token function">_PyEval_EvalFrame</span><span class="token punctuation">(</span>tstate<span class="token punctuation">,</span> frame<span class="token punctuation">,</span> exc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token comment">// 从 previous_item 中恢复出当前的执行信息，继续从上一个位置执行。</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    tstate<span class="token operator">-></span>exc_info <span class="token operator">=</span> gen<span class="token operator">-></span>gi_exc_state<span class="token punctuation">.</span>previous_item<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    gen<span class="token operator">-></span>gi_exc_state<span class="token punctuation">.</span>previous_item <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token comment">// 流程结束返回执行结果</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token operator">*</span>presult <span class="token operator">=</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token keyword">return</span> result <span class="token operator">?</span> PYGEN_RETURN <span class="token operator">:</span> PYGEN_ERROR<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>生成器为什么能在从上次停止的地方继续执行呢？是因为在停止的时候，执行权切换给调用者，此时生成器中<strong>把当前栈帧变成了前一个栈帧</strong>，也就是当前栈帧赋值给了内部栈帧的 previous。而在本节<strong>虚拟机栈帧</strong>部分，我们已经知道了调用者进行值传递的时候会把值给到上一个栈帧。而上一个栈帧其实就保存了当前栈帧的所有信息，代码对象执行进度等。所以它生成器又可以从停止的地方继续执行。</p><h4 id="生成器的暂停"><a class="anchor" href="#生成器的暂停">#</a> 生成器的暂停</h4><p>在上面的字节码中，我们可以看到一个 <code>yield</code> 相关的字节码<strong> YIELD_VALUE</strong>，该字节码负责了暂停的工作。所有字节码的执行都在 <code>Python/ceval.c</code> 中，在该文件的 <code>_PyEval_EvalFrameDefault</code> 函数中可以找到所有的字节码。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//_PyEval_EvalFrameDefault 匹配字节码的函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 在这里就能找到我们在上面看到的 YIELD_VALUE</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">TARGET</span><span class="token punctuation">(</span>YIELD_VALUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">assert</span><span class="token punctuation">(</span>frame<span class="token operator">-></span>depth <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    PyObject <span class="token operator">*</span>retval <span class="token operator">=</span> <span class="token function">POP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 代码 1</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    frame<span class="token operator">-></span>f_state <span class="token operator">=</span> FRAME_SUSPENDED<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">_PyFrame_SetStackPointer</span><span class="token punctuation">(</span>frame<span class="token punctuation">,</span> stack_pointer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">_Py_LeaveRecursiveCall</span><span class="token punctuation">(</span>tstate<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 代码 2</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">/* 代码 3 */</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    tstate<span class="token operator">-></span>cframe <span class="token operator">=</span> cframe<span class="token punctuation">.</span>previous<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    tstate<span class="token operator">-></span>cframe<span class="token operator">-></span>use_tracing <span class="token operator">=</span> cframe<span class="token punctuation">.</span>use_tracing<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> retval<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol><li>代码 1：在执行 <code>YIELD_VALUE</code> 之前已经执行了一条 <code>LOAD_FAST</code> ，而这个字节码把 <code>yield &lt;value&gt;</code> 中的常量 <code>value</code> 加载到了栈顶。所以第一行代码 <code>PyObject *retval = POP();</code> 就是加载出这个 <code>value</code> 作为返回值。</li><li>代码 2：当前栈帧离开调用链。</li><li>代码 3：切换执行权，执行权恢复上一个栈帧（也就是它的调用者）。</li></ol><p>生成器恢复的时候会继续执行下一条字节码 <code>STORE_FAST</code> ，该字节码就从栈顶获取到了 <code>send</code> 发来的数据。</p><h3 id="生成器源码总结"><a class="anchor" href="#生成器源码总结">#</a> 生成器源码总结</h3><p>在刚才的源码中可以分析出，生成器的核心执行流程，<strong>它复用生成器函数的帧栈，也就是源码中的 frame，当需要执行字节码的时候，它会把当前的执行信息保存在 previous_item 中，当字节码执行完之后，继续回到生成器函数的时候，会从 previous_item 中把执行信息拿出来，这样就可以保证继续从 yield 处继续执行。</strong></p><h1 id="生成器超进化-委托生成器"><a class="anchor" href="#生成器超进化-委托生成器">#</a> 生成器超进化 --&gt; 委托生成器</h1><h2 id="生成器的局限性"><a class="anchor" href="#生成器的局限性">#</a> 生成器的局限性</h2><p>在上一小节我们了解到了 <code>yield</code> 可以让生成器与调用者交互，但是它的局限性在于<strong>如果是多个生成器之间互动，会变得非常麻烦</strong>。你可能需要处理很多的异常，此外 <code>yield</code> 虽然可以用 <code>next</code> 将值给到调用者，但是<strong>调用者想拿到最后的 return 中的值，必须要捕获 <code>StopIteration</code> 异常，然后从异常中取得 return 的值</strong>。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">chain</span><span class="token punctuation">(</span><span class="token operator">*</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> it <span class="token keyword">in</span> iterables<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">for</span> i <span class="token keyword">in</span> it<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">yield</span> i</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> <span class="token string">'ok'</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>s <span class="token operator">=</span> <span class="token string">'abc'</span></pre></td></tr><tr><td data-num="8"></td><td><pre>b <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>instance <span class="token operator">=</span> chain<span class="token punctuation">(</span>s<span class="token punctuation">,</span> b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token builtin">next</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">except</span> StopIteration <span class="token keyword">as</span> e<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>  <span class="token comment"># ok</span></pre></td></tr></table></figure><p>可以看到，我们为了获取返回值 “ok”，就要处理一个 <code>StopIteration</code> 异常。并且为了处理两层嵌套的结构，我们依旧使用了两层 for 循环，看起来 yield 并没有起到什么特殊的效果（它与 return 作用差不多）。</p><h2 id="委托生成器"><a class="anchor" href="#委托生成器">#</a> 委托生成器</h2><p>为了解决 <code>yield</code> 的这些问题，在 PEP380 中提出的委托生成器 <code>yield from &lt;表达式&gt;</code> 这个语法，也是作为增强版的 <code>yield</code> 出现，先来简单的看一下它的作用。在上面的 <code>chain</code> 函数中，使用两层循环才完成，现在使用 <code>yield from</code> 仅需要一层循环。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">chain</span><span class="token punctuation">(</span><span class="token operator">*</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> it <span class="token keyword">in</span> iterables<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">yield</span> <span class="token keyword">from</span> it</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token string">'ok'</span></pre></td></tr><tr><td data-num="5"></td><td><pre>instance <span class="token operator">=</span> chain<span class="token punctuation">(</span>s<span class="token punctuation">,</span> b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># ['a', 'b', 'c', 0, 1, 2]</span></pre></td></tr></table></figure><h3 id="关键的伪代码"><a class="anchor" href="#关键的伪代码">#</a> 关键的伪代码</h3><p>当然它的作用肯定不仅仅只是增强循环功能，否则也不会被引入为新的特性。PEP380 中用一段<strong>伪代码</strong>解释了<strong>委托生成器的执行流程</strong>，我们可以从执行流程中看到，其实 <code>yield from</code> 的作用体现在两方面：一是调用者不需要考虑异常的处理，而是可以直接传递给生成器即可，二是调用者不用再从 <code>StopIteration</code> 中获取到 return 的返回值，而是可以直接从委托生成器的返回值接受。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>_i <span class="token operator">=</span> <span class="token builtin">iter</span><span class="token punctuation">(</span>EXPR<span class="token punctuation">)</span>  <span class="token comment"># 伪代码 1 将传进来的表达式变成迭代器 _i</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    _y <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>_i<span class="token punctuation">)</span>  <span class="token comment"># 伪代码 2 next () 调用迭代器 预激</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">except</span> StopIteration <span class="token keyword">as</span> _e<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    _r <span class="token operator">=</span> _e<span class="token punctuation">.</span>value  <span class="token comment"># 到 StopIteration 时候把 return 的值给_r。</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># 当获取到值 _y 或者 _r 之后执行 else 里面的逻辑</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment"># 注意这里是个死循环</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token comment"># 循环第一步就是用 yield 产出这个值</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">#  并且又接收了调用者传过来的值 _s</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            _s <span class="token operator">=</span> <span class="token keyword">yield</span> _y  <span class="token comment"># 伪代码 3</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">except</span> GeneratorExit <span class="token keyword">as</span> _e<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">except</span> BaseException <span class="token keyword">as</span> _e<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment"># ...... 处理了两个异常。</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># 在异常之后又走到了这个 else</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment"># 注意这个_s 是我们接到的调用者传过来的值，用来继续迭代</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment"># 如果它是 None，则调用 next (), 否则调用 send () 将它发送给_i</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">if</span> _s <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    _y <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>_i<span class="token punctuation">)</span> <span class="token comment"># 伪代码 4</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token keyword">else</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    _y <span class="token operator">=</span> _i<span class="token punctuation">.</span>send<span class="token punctuation">(</span>_s<span class="token punctuation">)</span> <span class="token comment"># 伪代码 5</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token keyword">except</span> StopIteration <span class="token keyword">as</span> _e<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                _r <span class="token operator">=</span> _e<span class="token punctuation">.</span>value</pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token keyword">break</span></pre></td></tr><tr><td data-num="26"></td><td><pre>RESULT <span class="token operator">=</span> _r  <span class="token comment"># _r 就是最后 return 中的值 也是 yield form 的返回值</span></pre></td></tr></table></figure><p>总结一下这段委托生成器的作用：</p><blockquote><p>_i: 生成器函数；<br>_y: 生成器产出的值；<br>_r: 最终结果，生成器 return 的值。<br>_s: 调用者发送的值；<br>_e: 产生的异常；</p></blockquote><ol><li>对于委托生成器左面的表达式，先变成迭代器，然后预激迭代器，产出第一个值_y，如果没有可产出值，则直接把 return 的返回值给_r；</li><li>接下来是一个死循环。循环第一步，用 yield 把_y 返回给调用者，并接收调用者传过来的值_s；</li><li>接到_s 之后，根据_s 是否为 None，调用 next () 或者 send (_s) 让迭代器_i 继续产出值_y，直到_i 迭代完成 (遇到 StopIteration) 退出死循环，返回 return 的值。</li></ol><p>分析完这段代码之后，可以发现委托生成器的作用远远不止增强嵌套迭代的处理，而是在生成器和调用者之间打开了一条通道，把最外层的调用者和内层生成器联系起来。</p><h3 id="实际的例子"><a class="anchor" href="#实际的例子">#</a> 实际的例子</h3><p>引用《流畅的 python》中的一个实际例子，来说明委托生成器的工作流程。</p><p>该例子<strong>计算一些学生的身高和体重的平均值，生成一个数据报告</strong>。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 测试数据集</span></pre></td></tr><tr><td data-num="2"></td><td><pre>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token string">'girls;kg'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">40.9</span><span class="token punctuation">,</span> <span class="token number">38.5</span><span class="token punctuation">,</span> <span class="token number">44.3</span><span class="token punctuation">,</span> <span class="token number">42.2</span><span class="token punctuation">,</span> <span class="token number">45.2</span><span class="token punctuation">,</span> <span class="token number">41.7</span><span class="token punctuation">,</span> <span class="token number">44.5</span><span class="token punctuation">,</span> <span class="token number">38.0</span><span class="token punctuation">,</span> <span class="token number">40.6</span><span class="token punctuation">,</span> <span class="token number">44.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token string">'girls;m'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1.6</span><span class="token punctuation">,</span> <span class="token number">1.51</span><span class="token punctuation">,</span> <span class="token number">1.4</span><span class="token punctuation">,</span> <span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">1.41</span><span class="token punctuation">,</span> <span class="token number">1.39</span><span class="token punctuation">,</span> <span class="token number">1.33</span><span class="token punctuation">,</span> <span class="token number">1.46</span><span class="token punctuation">,</span> <span class="token number">1.45</span><span class="token punctuation">,</span> <span class="token number">1.43</span><span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token string">'boy;kg'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">39.0</span><span class="token punctuation">,</span> <span class="token number">40.8</span><span class="token punctuation">,</span> <span class="token number">43.2</span><span class="token punctuation">,</span> <span class="token number">40.8</span><span class="token punctuation">,</span> <span class="token number">43.1</span><span class="token punctuation">,</span> <span class="token number">38.6</span><span class="token punctuation">,</span> <span class="token number">41.4</span><span class="token punctuation">,</span> <span class="token number">40.6</span><span class="token punctuation">,</span> <span class="token number">36.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token string">'boy;m'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1.38</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">1.32</span><span class="token punctuation">,</span> <span class="token number">1.25</span><span class="token punctuation">,</span> <span class="token number">1.37</span><span class="token punctuation">,</span> <span class="token number">1.48</span><span class="token punctuation">,</span> <span class="token number">1.25</span><span class="token punctuation">,</span> <span class="token number">1.49</span><span class="token punctuation">,</span> <span class="token number">1.46</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>Result <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Result'</span><span class="token punctuation">,</span> <span class="token string">'count average'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">def</span> <span class="token function">averager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token triple-quoted-string string">"""计算平均值函数  生成器"""</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    total <span class="token operator">=</span> <span class="token number">0.0</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    cnt <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    average <span class="token operator">=</span> <span class="token boolean">None</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        term <span class="token operator">=</span> <span class="token keyword">yield</span> average  <span class="token comment"># 代码 g1</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token keyword">not</span> term<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">break</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        total <span class="token operator">+=</span> term</pre></td></tr><tr><td data-num="20"></td><td><pre>        cnt <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        average <span class="token operator">=</span> total <span class="token operator">/</span> cnt  <span class="token comment"># 代码 g2</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">return</span> Result<span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> average<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">def</span> <span class="token function">grouper</span><span class="token punctuation">(</span>results<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token triple-quoted-string string">"""委托生成器"""</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        results<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token keyword">from</span> averager<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token keyword">def</span> <span class="token function">report</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token triple-quoted-string string">"""报告产出函数"""</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">for</span> key<span class="token punctuation">,</span> result <span class="token keyword">in</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>results<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        group<span class="token punctuation">,</span> unit <span class="token operator">=</span> key<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">&#123;</span>result<span class="token punctuation">.</span>count<span class="token punctuation">&#125;</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">&#123;</span>group<span class="token punctuation">&#125;</span></span><span class="token string"> averaging </span><span class="token interpolation"><span class="token punctuation">&#123;</span>result<span class="token punctuation">.</span>average<span class="token punctuation">&#125;</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">&#123;</span>unit<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token triple-quoted-string string">"""主要调用者函数"""</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    results <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token keyword">for</span> key<span class="token punctuation">,</span> vals <span class="token keyword">in</span> data<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 代码 0 外循环</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        group <span class="token operator">=</span> grouper<span class="token punctuation">(</span>results<span class="token punctuation">,</span> key<span class="token punctuation">)</span>  <span class="token comment"># 代码 1</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token builtin">next</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span>  <span class="token comment"># 代码 2</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">for</span> val <span class="token keyword">in</span> vals<span class="token punctuation">:</span>  <span class="token comment"># 内循环</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            group<span class="token punctuation">.</span>send<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token comment"># 代码 3</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        group<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>  <span class="token comment"># 代码 4</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    report<span class="token punctuation">(</span>results<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="46"></td><td><pre></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token comment"># 执行结果</span></pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token punctuation">&#123;</span><span class="token string">'girls;kg'</span><span class="token punctuation">:</span> Result<span class="token punctuation">(</span>count<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> average<span class="token operator">=</span><span class="token number">42.040000000000006</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'girls;m'</span><span class="token punctuation">:</span> Result<span class="token punctuation">(</span>count<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> average<span class="token operator">=</span><span class="token number">1.4279999999999997</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'boy;kg'</span><span class="token punctuation">:</span> Result<span class="token punctuation">(</span>count<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span> average<span class="token operator">=</span><span class="token number">40.422222222222224</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'boy;m'</span><span class="token punctuation">:</span> Result<span class="token punctuation">(</span>count<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span> average<span class="token operator">=</span><span class="token number">1.3888888888888888</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="49"></td><td><pre><span class="token number">9</span> boy averaging <span class="token number">40.422222222222224</span> kg</pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token number">9</span> boy averaging <span class="token number">1.3888888888888888</span> m</pre></td></tr><tr><td data-num="51"></td><td><pre><span class="token number">10</span> girls averaging <span class="token number">42.040000000000006</span> kg</pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token number">10</span> girls averaging <span class="token number">1.4279999999999997</span> m</pre></td></tr></table></figure><p>为了弄懂委托生成器到底是怎么执行的，我们把这个例子代入到委托生成器的执行流程的伪代码中 (后面用<strong>伪代码</strong>代指)。</p><p>无论是生成器还是委托生成器，都是从调用者调用之后才开始执行的，所以先看<strong>调用者函数</strong>。</p><ol><li>代码 1，<strong>初始化委托生成器</strong>，传入了两个参数。细心观察，发现这两个参数对函数主体并无影响，仅仅用做接收委托生成器的结果，而我们知道委托生成器的执行结果，在于右面表达式最终的返回值 (return)；</li><li>调用函数执行代码 2，预先激活委托生成器。<strong>让出执行权给委托生成器</strong>，对应伪代码中执行 <code>_i=iter(averager())</code> (伪代码 1)，获取到平均数函数的生成器_i。然后伪代码再执行 <code>_y=next(_i)</code> (伪代码 2)；</li><li><strong>此时执行权切换到计算平均值函数 (生成器)</strong>，生成器函数执行到代码 g1，产出第一个 <code>average</code> ，并且<strong>让出执行权</strong>；</li><li><strong>委托生成器再次获取执行权</strong>。伪代码 2 中_y 变成了这个 <code>average</code> (None)，继续执行 <code>_s=yield _y</code> (伪代码 3)，将_y 产出给调用者函数，并且<strong>让出执行权</strong>；</li><li><strong>调用者获取执行权</strong>，执行到代码 3。代码 3 调用 send (val) 函数，发送 val 到_i，<strong>让出执行权</strong>；</li><li><strong>委托生成器获取到执行权</strong>，伪代码 3 中的_s 变成接收到的 val。继续执行因为_s 有值，执行到伪代码 5，将值传递给生成器_i，<strong>并且让出执行权</strong>。</li><li><strong>生成器获取执行权</strong>，此时生成器_i 接收到 val 值之后，执行到代码 g2，算出平均值 <code>average</code> ，并且通过死循环，执行到代码 g1，将 <code>average</code> 再通过 <code>yield</code> 从传递给委托生成器，并且<strong>让出执行权</strong>。</li><li><strong>委托生成器获取到执行权</strong>，委托生成器中伪代码 5 的_y 接收到了值，变成了 <code>average</code> ，委托生成器继续执行，通过死循环来到伪代码 3，伪代码 3 中的 <code>yield</code> ，将 <code>average</code> 产出给调用者函数，并且<strong>让出执行权</strong>。</li><li><strong>调用者获得执行权</strong>，调用者继续执行 send (val)，也就是，重复执行过程 5~9。而<strong>每次执行到步骤 7 都会更新 <code>average</code> </strong>。</li><li>当最后调用者函数中内循环结束之后，调用 send (None)。<strong>执行权来到委托生成器</strong>，此时委托生成器接到了 None，执行 <code>_y = next(_i)</code> (伪代码 4)，<strong>执行权来到生成器</strong>，此时生成器函数中代码 g1 的 term 参数就是 None，从而触发 break，跳出死循环，执行 return 语句。</li><li>此时<strong>执行权再次来到委托生成器</strong>，因为 <code>yield from &lt;表达式&gt;</code> 的返回值就是右侧表达式的返回值，所以 <code>results[key]</code> 的值就是生成器最终的值。</li><li><strong>委托生成器赋值完成之后，执行权再次来到生成器，在代码 0 处执行外循环。重复执行步骤 1~11。直到外循环也执行完成，向下执行打印语句，打印出 results 的结果。</strong></li></ol><p>这段代码分析中，我把<strong>执行权切换</strong>的过程用显示的标记了出来，所以会略显啰嗦。但是其实它并不复杂，你可以比较明显的发现委托生成器的作用，它就像一个<strong>中间人</strong>一样，在调用者和其他生成器之间进行协调。它把调用者的值给生成器，又把生成器的结果给调用者，在生成器执行结束之后，把 return 的返回值给调用者。在这些过程中调用者不必管任何的异常处理，并且不需要再从 <code>StopIteration</code> 获取返回值。</p><h1 id="生成器究极进化-协程的-await"><a class="anchor" href="#生成器究极进化-协程的-await">#</a> 生成器究极进化 --&gt; 协程的 await</h1><p>如果大家已经了解协程的概念，会发现生成器本身就是一种协同程序。事实也确实如此，在 python 初期 (2.5 版本) 确实就把生成器当做协程使用，并为此产生了一个新的提案 (PEP342)。</p><h2 id="为生成器实现协程做的努力"><a class="anchor" href="#为生成器实现协程做的努力">#</a> 为生成器实现协程做的努力</h2><p>在该提案中为生成器增加了一些功能，让生成器更加的符合协程的特性。</p><ol><li>将 <code>yield</code> 定义成表达式，而不是普通的语句。这期间的区别就是表达式可以有返回值，可以接收参数。</li><li>增加一个函数 <code>send(arg)</code> : 发送一个值到生成器作为参数。并返回生成器的下一个值。</li><li>增加一个函数 <code>throw()</code> : 允许调用者获取生成器的值，并在生成器停止时，引发异常。</li><li>增加一个函 <code>close()</code> : 该函数确保生成器可以正确停止。在停止时触发 <code>GeneratorExit</code> 或者 <code>StopIteration</code> ，如果停止时依旧产出值，触发 <code>RuntimeError</code> 。如果引发其他异常，则直接把这个异常给调用者处理。</li><li>确保生成器在垃圾回收的时候正确调用上面的 <code>close()</code> 。</li><li>因为可以显示的调用 <code>close()</code> ，所以也可以在 <code>try/finally</code> 语句中调用了 (无法显示调用 close，就无法正确在 finally 中关闭协程)。</li></ol><p>在知道 PEP342 中做过的这些更新之后，我们发现上一小节的例子<strong>报告身高体重平均值</strong>就是一个由生成器实现的协程。</p><h2 id="生成器实现协程的缺点"><a class="anchor" href="#生成器实现协程的缺点">#</a> 生成器实现协程的缺点</h2><p>生成器虽然可以实现协程，且又有委托生成器这种增强语法，但是它终究不是真正的协程。这种方法有一些缺点：</p><ol><li>协程和生成器混淆，他们使用相同的语法，尤其对新手很不友好。</li><li>函数是否是协程取决于函数中是否有 <code>yield</code> 或者 <code>yield from</code> ，如果在重构的过程中弄丢了，会出现不明显的事故。</li><li>异步调用的时候只支持了 <code>yield</code> ，而忽略了 <code>for</code> 和 <code>with</code> 等特性。</li></ol><h2 id="真正的协程"><a class="anchor" href="#真正的协程">#</a> 真正的协程</h2><p>为了使协程成为 python 中一个独立的概念，使它更加易用，贴合协程这个概念，并且与生成器区分开，在 PEP492 中，提出了新的语法 <code>async/await</code> ，使用 <code>async</code> 来定义协程，并使用 <code>await</code> 来切换执行权，并且使用一个事件循环来不断的调度协程，在协程遇到 IO 操作的时候切换执行权，并在协程完成之后返回给调用者。</p><h3 id="async"><a class="anchor" href="#async">#</a> async</h3><p>我们都知道 <code>def</code> 关键字可以用来定义一个可调用对象，但是使用 <code>async def</code> 定义的确实一个协程，也就是在实例化之后，它不会被调用，而是转成一个<strong>协程对象</strong>，如下所示：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">coro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">pass</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 使用 async def 定义的是一个协程对象</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>coro<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># &lt;coroutine object coro...></span></pre></td></tr></table></figure><h3 id="awaitawaitable"><a class="anchor" href="#awaitawaitable">#</a> await/awaitable</h3><p>而配合协程使用的是 <code>await &lt;awaitable object&gt;</code> 语句，该语句相较于 <code>yield from &lt;exec&gt;</code> 表达的含义更准确，并且在其他语言中也使用的是这个关键字。</p><p><code>await</code> 与 <code>yield from</code> 从<strong>作用方面</strong>看是<strong>完全相同</strong>的，但是 <code>await</code> 是为了配合协程使用的，因此与 <code>yield from</code> 不同的是 <code>await</code> 后面跟的表达式必须是<strong> awaitable</strong> 对象。</p><p>而在该提案 (PEP492) 中提出了如下三个<strong> awaitable</strong> 对象：</p><ol><li><code>coroutine</code> 对象，也就是协程。当一个协程跟在 <code>await</code> 后面，并且 <code>await</code> 把执行权切换给它的时候，它就会执行。</li><li><code>asyncio.Future</code> 也是 <code>abaitable</code> 类型的对象，当它跟在 <code>await</code> 后面并获取执行权的时候，如果已经执行完毕， <code>await</code> 立刻返回该结果 (如果是异常，则立刻引发该异常)，如果没执行完，会持续等待当前 Future 执行完毕，并在执行完毕后返回结果 (引发异常)。</li><li>实现了魔术方法 <code>__await__</code> 的对象，当这种对象跟在 <code>await</code> 后面并获取执行权的时候，会执行 <code>__await__</code> 函数。</li></ol><h2 id="实际的例子-2"><a class="anchor" href="#实际的例子-2">#</a> 实际的例子</h2><p>这里我想用一个实际的例子，来演示 <code>await</code> 在协程中的应用。在这个例子中，我们<strong>启动一个微型服务器，并且通过常规方式和 async/await 的方式访问它，通过对比执行时间，来看他们的执行效果。</strong><br>(Ps：这个例子只为了简单演示 <code>await</code> 和 <code>yield from</code> 在实际使用中的区别，<strong>并非演示实际操作</strong>，真实工程场景中的运用后续文章详述)</p><h3 id="服务端"><a class="anchor" href="#服务端">#</a> 服务端</h3><p>服务端的函数很简单，它的主要功能是接收一个参数 <code>number</code> 并将它原路返回。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> asyncio</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> aiohttp <span class="token keyword">import</span> web</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">handler</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    data <span class="token operator">=</span> request<span class="token punctuation">.</span>query</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 协程 模拟耗时 IO</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> web<span class="token punctuation">.</span>json_response<span class="token punctuation">(</span>text<span class="token operator">=</span>data<span class="token punctuation">[</span><span class="token string">'number'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>app <span class="token operator">=</span> web<span class="token punctuation">.</span>Application<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>app<span class="token punctuation">.</span>router<span class="token punctuation">.</span>add_post<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>web<span class="token punctuation">.</span>run_app<span class="token punctuation">(</span>app<span class="token punctuation">)</span></pre></td></tr></table></figure><p>主要思路就是启动一个支持异步的服务，并且给该服务设置一秒的延时，但是注意这里的延时是使用的 <code>await asyncio.sleep(1)</code> 这样可以让请求和延时操作之间来回切换。</p><p>也就是说当服务接到请求并执行到 <code>await</code> 之后，切换执行权到延迟操作， <code>sleep</code> 会返回一个 <code>await future</code> ，该 <code>future</code> 需要 1s 执行时间，在这时间内如果服务接到了另外的请求，那么执行权就会切换，继续执行新的请求，就好像 <code>sleep</code> 的 1s 延迟叠加了起来一样。</p><h3 id="客户端"><a class="anchor" href="#客户端">#</a> 客户端</h3><p>朴实无华的同步请求。三个请求耗时 3s。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    res <span class="token operator">=</span> requests<span class="token punctuation">.</span>request<span class="token punctuation">(</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token string">'POST'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token string">'http://127.0.0.1:8080'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        params<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">'number'</span><span class="token punctuation">:</span> i<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">)</span>  <span class="token comment"># 0， 1， 2</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span>  <span class="token comment"># 3.0330724716186523</span></pre></td></tr></table></figure><p>使用了 <code>async/await</code> 的异步请求。三个请求耗时 1s。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> aiohttp</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> asyncio</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">fetch</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">async</span> <span class="token keyword">with</span> client<span class="token punctuation">.</span>request<span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span> <span class="token string">'http://127.0.0.1:8080'</span><span class="token punctuation">,</span> params<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">'number'</span><span class="token punctuation">:</span> number<span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token keyword">as</span> resp<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">await</span> resp<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    </pre></td></tr><tr><td data-num="8"></td><td><pre>    </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">async</span> <span class="token keyword">with</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> client<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            tasks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>fetch<span class="token punctuation">(</span>client<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        done<span class="token punctuation">,</span> pending <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">for</span> res <span class="token keyword">in</span> done<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 0, 1, 2</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span>  <span class="token comment"># 1.0144481658935547</span></pre></td></tr></table></figure><p>在异步请求中，我们使用了一个异步的请求库 <code>aiohttp</code> ，该库实现了两个必要的魔术方法 <code>__aenter__，__aexit__</code> ，使它变成了 <code>awaitable</code> 对象。上面的代码将多个请求任务封装到一个事件循环去执行。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>本文主要目的是引导读者熟悉与协程相关的重要知识<strong>生成器</strong>。分四个小节，介绍了由生成器到协程的演进过程。</p><p><strong>完结</strong></p><div class="tags"><a href="/tags/Asyncio%E4%B8%93%E9%A2%98/" rel="tag"><i class="ic i-tag"></i> Asyncio专题</a> <a href="/tags/%E7%94%9F%E6%88%90%E5%99%A8/" rel="tag"><i class="ic i-tag"></i> 生成器</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"><i class="ic i-tag"></i> 源码分析</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-07-27 22:27:40" itemprop="dateModified" datetime="2022-07-27T22:27:40+08:00">2022-07-27</time> </span><span id="python中的生成器(yield与yield from)/" class="item leancloud_visitors" data-flag-title="python中的生成器(yield与yield from)" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/wechatpay.png" alt="A Cat Without Sugar 微信支付"><p>微信支付</p></div><div><img data-src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/alipay.png" alt="A Cat Without Sugar 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>A Cat Without Sugar <i class="ic i-at"><em>@</em></i>小猫咪吃python</li><li class="link"><strong>本文链接：</strong> <a href="http://yoursite.com/python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8(yield%E4%B8%8Eyield%20from)/" title="python中的生成器(yield与yield from)">http://yoursite.com/python中的生成器(yield与yield from)/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/%E7%94%A8%E6%81%8B%E7%88%B1%E5%BE%AA%E7%8E%AF%E7%AE%97%E6%B3%95%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E6%95%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciszlczyj20zk0m816d.jpg" title="用恋爱循环算法来解决二分图的最大匹配数"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 搜索与图论</span><h3>用恋爱循环算法来解决二分图的最大匹配数</h3></a></div><div class="item right"><a href="/LeetCode%20913.%20%E7%8C%AB%E5%92%8C%E8%80%81%E9%BC%A0/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipew8gmvyj20zk0m87wh.jpg" title="LeetCode 913. 猫和老鼠"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 搜索与图论</span><h3>LeetCode 913. 猫和老鼠</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB"><span class="toc-number">1.</span> <span class="toc-text">导读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E9%98%B6%E6%AE%B5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">初始阶段，迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">第二阶段，生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E5%A7%94%E6%89%98%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">第三阶段，委托生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E9%98%B6%E6%AE%B5%E5%8D%8F%E7%A8%8B-asyncawait"><span class="toc-number">1.4.</span> <span class="toc-text">现阶段，协程 async&#x2F;await</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%BC%E5%B9%B4%E6%9C%9F%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator"><span class="toc-number">2.</span> <span class="toc-text">幼年期的迭代器 iterator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E5%8C%96-%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">迭代器进化 --&gt; 生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yield"><span class="toc-number">3.2.</span> <span class="toc-text">yield</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">有两种方式定义生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%AE%8C%E5%85%A8%E6%94%AF%E6%8C%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.2.2.</span> <span class="toc-text">生成器完全支持迭代器协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E4%BC%9A%E8%AE%B0%E5%BD%95%E5%87%BD%E6%95%B0%E5%BD%93%E5%89%8D%E6%89%A7%E8%A1%8C%E4%BD%8D%E7%BD%AE%E4%B8%8B%E6%AC%A1%E6%89%A7%E8%A1%8C%E4%BB%8E%E8%AF%A5%E4%BD%8D%E7%BD%AE%E5%BC%80%E5%A7%8B"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">生成器会记录函数当前执行位置，下次执行从该位置开始</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">字节码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%B8%A7"><span class="toc-number">3.3.2.</span> <span class="toc-text">虚拟机栈帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%BA%90%E7%A0%81"><span class="toc-number">3.3.3.</span> <span class="toc-text">生成器源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ncludecpythongenobjecth"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">nclude&#x2F;cpython&#x2F;genobject.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bjectsgenobjectc"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">bjects&#x2F;genobject.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E6%9A%82%E5%81%9C"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">生成器的暂停</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.4.</span> <span class="toc-text">生成器源码总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%B6%85%E8%BF%9B%E5%8C%96-%E5%A7%94%E6%89%98%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">生成器超进化 --&gt; 委托生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">生成器的局限性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">委托生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.1.</span> <span class="toc-text">关键的伪代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">4.2.2.</span> <span class="toc-text">实际的例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E7%A9%B6%E6%9E%81%E8%BF%9B%E5%8C%96-%E5%8D%8F%E7%A8%8B%E7%9A%84-await"><span class="toc-number">5.</span> <span class="toc-text">生成器究极进化 --&gt; 协程的 await</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E7%94%9F%E6%88%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E5%81%9A%E7%9A%84%E5%8A%AA%E5%8A%9B"><span class="toc-number">5.1.</span> <span class="toc-text">为生成器实现协程做的努力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">5.2.</span> <span class="toc-text">生成器实现协程的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%8D%8F%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">真正的协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async"><span class="toc-number">5.3.1.</span> <span class="toc-text">async</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awaitawaitable"><span class="toc-number">5.3.2.</span> <span class="toc-text">await&#x2F;awaitable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%9A%84%E4%BE%8B%E5%AD%90-2"><span class="toc-number">5.4.</span> <span class="toc-text">实际的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">5.4.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.4.2.</span> <span class="toc-text">客户端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8(yield%E4%B8%8Eyield%20from)/" rel="bookmark" title="python中的生成器(yield与yield from)">python中的生成器(yield与yield from)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="A Cat Without Sugar" data-src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/images/avatar.jpg"><p class="name" itemprop="name">A Cat Without Sugar</p><div class="description" itemprop="description">孤独与剑，自由与酒</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">35</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">9</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">50</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/%E7%94%A8%E6%81%8B%E7%88%B1%E5%BE%AA%E7%8E%AF%E7%AE%97%E6%B3%95%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E6%95%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/LeetCode%20913.%20%E7%8C%AB%E5%92%8C%E8%80%81%E9%BC%A0/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" title="分类于 搜索与图论">搜索与图论</a></div><span><a href="/%E7%94%A8%E6%81%8B%E7%88%B1%E5%BE%AA%E7%8E%AF%E7%AE%97%E6%B3%95%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E6%95%B0/" title="用恋爱循环算法来解决二分图的最大匹配数">用恋爱循环算法来解决二分图的最大匹配数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" title="分类于 书籍推荐">书籍推荐</a></div><span><a href="/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%9C%AC%E4%B9%A6--%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/" title="推荐一本书《被讨厌的勇气》">推荐一本书《被讨厌的勇气》</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" title="分类于 搜索与图论">搜索与图论</a></div><span><a href="/%E3%80%90%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98%E3%80%91%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%B8%B8%E8%A7%84%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%89%AA%E6%9E%9D%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/" title="深度优先搜索常规思路及剪枝方式（上）">深度优先搜索常规思路及剪枝方式（上）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/" title="分类于 数学">数学</a></div><span><a href="/%E6%95%B0%E8%AE%BA%E4%B8%AD%E7%9A%84%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/" title="数论中的乘法逆元">数论中的乘法逆元</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="分类于 动态规划">动态规划</a></div><span><a href="/AcWing%20898.%20%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2/" title="AcWing 898. 数字三角形">AcWing 898. 数字三角形</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/" title="分类于 数学">数学</a></div><span><a href="/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E9%97%AE%E9%A2%98(%E4%BA%8C)/" title="有趣的博弈论问题(二)">有趣的博弈论问题(二)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/" title="分类于 贪心">贪心</a></div><span><a href="/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%B8%B8%E8%A7%84%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/" title="贪心算法的常规思路与实战应用">贪心算法的常规思路与实战应用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/" title="分类于 数学">数学</a></div><span><a href="/%E7%A5%9E%E5%A5%87%E7%9A%84%E5%BF%AB%E9%80%9F%E5%B9%82/" title="神奇的快速幂">神奇的快速幂</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="分类于 动态规划">动态规划</a></div><span><a href="/AcWing%20291.%20%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3/" title="AcWing 291. 蒙德里安的梦想">AcWing 291. 蒙德里安的梦想</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" title="分类于 搜索与图论">搜索与图论</a></div><span><a href="/%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A%E7%9A%84%E6%90%9C%E7%B4%A2%E4%B9%8B%E8%B6%85%E7%BB%8F%E5%85%B8flood%20fill%E9%97%AE%E9%A2%98%E6%94%BB%E7%95%A5/" title="看完必会的搜索之超经典flood fill问题攻略">看完必会的搜索之超经典flood fill问题攻略</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">A Cat Without Sugar @ The Cat to eat Python</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">183k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">2:46</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"python中的生成器(yield与yield from)/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{appId:"TsHNizG5g9yTU8EUAa1EIkH5-gzGzoHsz",appKey:"KSmBGGzCyE4Pnop6qF4aD39B",placeholder:"ヽ(○´∀`)ﾉ♪",pageSize:10,lang:"zh-CN"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//cdn.jsdelivr.net/gh/cjrzs/KittenToEatPython@latest/js/app.js?v=0.2.5"></script></body></html>